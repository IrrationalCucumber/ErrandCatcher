{"ast":null,"code":"function tryGettingFetch() {\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n  return null;\n}\nclass ClientConfig {\n  constructor() {\n    /**\n     * MapTiler Cloud API key\n     */\n    this._apiKey = \"\";\n    /**\n     * The fetch function. To be set if in Node < 18, otherwise\n     * will be automatically resolved.\n     */\n    this._fetch = tryGettingFetch();\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    this._fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return this._fetch;\n  }\n}\nconst config = new ClientConfig();\nconst LanguageGeocoding = {\n  AUTO: \"auto\",\n  ALBANIAN: \"sq\",\n  ARABIC: \"ar\",\n  ARMENIAN: \"hy\",\n  AZERBAIJANI: \"az\",\n  BELORUSSIAN: \"be\",\n  BOSNIAN: \"bs\",\n  BRETON: \"br\",\n  BULGARIAN: \"bg\",\n  CATALAN: \"ca\",\n  CHINESE: \"zh\",\n  CROATIAN: \"hr\",\n  CZECH: \"cs\",\n  DANISH: \"da\",\n  DUTCH: \"nl\",\n  ENGLISH: \"en\",\n  ESPERANTO: \"eo\",\n  ESTONIAN: \"et\",\n  FINNISH: \"fi\",\n  FRENCH: \"fr\",\n  FRISIAN: \"fy\",\n  GEORGIAN: \"ka\",\n  GERMAN: \"de\",\n  GREEK: \"el\",\n  HEBREW: \"he\",\n  HUNGARIAN: \"hu\",\n  ICELANDIC: \"is\",\n  IRISH: \"ga\",\n  ITALIAN: \"it\",\n  JAPANESE: \"ja\",\n  KANNADA: \"kn\",\n  KAZAKH: \"kk\",\n  KOREAN: \"ko\",\n  ROMAN_LATIN: \"la\",\n  LATVIAN: \"lv\",\n  LITHUANIAN: \"lt\",\n  LUXEMBOURGISH: \"lb\",\n  MACEDONIAN: \"mk\",\n  MALTESE: \"mt\",\n  NORWEGIAN: \"no\",\n  POLISH: \"pl\",\n  PORTUGUESE: \"pt\",\n  ROMANIAN: \"ro\",\n  ROMANSH: \"rm\",\n  RUSSIAN: \"ru\",\n  SCOTTISH_GAELIC: \"gd\",\n  SERBIAN_CYRILLIC: \"sr\",\n  SLOVAK: \"sk\",\n  SLOVENE: \"sl\",\n  SPANISH: \"es\",\n  SWEDISH: \"sv\",\n  THAI: \"th\",\n  TURKISH: \"tr\",\n  UKRAINIAN: \"uk\",\n  WELSH: \"cy\"\n};\nconst languageCodeSet = new Set(Object.values(LanguageGeocoding));\nfunction getAutoLanguageGeocoding() {\n  if (typeof navigator === \"undefined\") {\n    return Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n  }\n  const canditatelangs = Array.from(new Set(navigator.languages.map(l => l.split(\"-\")[0]))).filter(l => languageCodeSet.has(l));\n  return canditatelangs.length ? canditatelangs[0] : LanguageGeocoding.ENGLISH;\n}\nvar __async$4 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction callFetch(_0) {\n  return __async$4(this, arguments, function* (resource, options = {}) {\n    if (config.fetch === null) {\n      throw new Error(\"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\");\n    }\n    if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n      throw new Error(\"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\");\n    }\n    return config.fetch(resource, options);\n  });\n}\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\"\n};\nObject.freeze(defaults);\nclass ServiceError extends Error {\n  constructor(res, customMessage = \"\") {\n    super(`Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`);\n    this.res = res;\n  }\n}\nvar __async$3 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst customMessages$3 = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction addLanguageGeocodingOptions(searchParams, options) {\n  if (options.language == void 0) {\n    return;\n  }\n  const languages = Array.from(new Set((Array.isArray(options.language) ? options.language : [options.language]).map(lang => lang === LanguageGeocoding.AUTO ? getAutoLanguageGeocoding() : lang))).join(\",\");\n  searchParams.set(\"language\", languages);\n}\nfunction addCommonForwardAndReverseGeocodingOptions(searchParams, options) {\n  var _a;\n  searchParams.set(\"key\", (_a = options.apiKey) != null ? _a : config.apiKey);\n  if (options.limit != void 0) {\n    searchParams.set(\"limit\", String(options.limit));\n  }\n  if (options.types != void 0) {\n    searchParams.set(\"types\", options.types.join(\",\"));\n  }\n  addLanguageGeocodingOptions(searchParams, options);\n}\nfunction addForwardGeocodingOptions(searchParams, options) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n  if (options.bbox != void 0) {\n    searchParams.set(\"bbox\", options.bbox.join(\",\"));\n  }\n  if (options.proximity != void 0) {\n    searchParams.set(\"proximity\", options.proximity.join(\",\"));\n  }\n  if (options.country != void 0) {\n    searchParams.set(\"country\", options.country.join(\",\"));\n  }\n  if (options.fuzzyMatch != void 0) {\n    searchParams.set(\"fuzzyMatch\", options.fuzzyMatch ? \"true\" : \"false\");\n  }\n  if (options.autocomplete != void 0) {\n    searchParams.set(\"autocomplete\", options.autocomplete ? \"true\" : \"false\");\n  }\n}\nfunction forward(_0) {\n  return __async$3(this, arguments, function* (query, options = {}) {\n    var _a;\n    if (typeof query !== \"string\" || query.trim().length === 0) {\n      throw new Error(\"The query must be a non-empty string\");\n    }\n    const endpoint = new URL(`geocoding/${encodeURIComponent(query)}.json`, defaults.maptilerApiURL);\n    const {\n      searchParams\n    } = endpoint;\n    addForwardGeocodingOptions(searchParams, options);\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, (_a = customMessages$3[res.status]) != null ? _a : \"\");\n    }\n    const obj = yield res.json();\n    return obj;\n  });\n}\nfunction reverse(_0) {\n  return __async$3(this, arguments, function* (position, options = {}) {\n    var _a;\n    if (!Array.isArray(position) || position.length < 2) {\n      throw new Error(\"The position must be an array of form [lng, lat].\");\n    }\n    const endpoint = new URL(`geocoding/${position[0]},${position[1]}.json`, defaults.maptilerApiURL);\n    addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, (_a = customMessages$3[res.status]) != null ? _a : \"\");\n    }\n    const obj = yield res.json();\n    return obj;\n  });\n}\nfunction byId(_0) {\n  return __async$3(this, arguments, function* (id, options = {}) {\n    var _a;\n    const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n    addLanguageGeocodingOptions(endpoint.searchParams, options);\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, (_a = customMessages$3[res.status]) != null ? _a : \"\");\n    }\n    const obj = yield res.json();\n    return obj;\n  });\n}\nfunction batch(_0) {\n  return __async$3(this, arguments, function* (queries, options = {}) {\n    var _a;\n    if (!queries.length) {\n      return [];\n    }\n    const joinedQuery = queries.map(query => encodeURIComponent(query)).join(\";\");\n    const endpoint = new URL(`geocoding/${joinedQuery}.json`, defaults.maptilerApiURL);\n    const {\n      searchParams\n    } = endpoint;\n    addForwardGeocodingOptions(searchParams, options);\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, (_a = customMessages$3[res.status]) != null ? _a : \"\");\n    }\n    const obj = yield res.json();\n    return queries.length === 1 ? [obj] : obj;\n  });\n}\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch,\n  language: LanguageGeocoding\n};\nvar __async$2 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst customMessages$2 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction info() {\n  return __async$2(this, arguments, function* (options = {}) {\n    var _a;\n    const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n    endpoint.searchParams.set(\"key\", (_a = options.apiKey) != null ? _a : config.apiKey);\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : \"\");\n    }\n    const obj = yield res.json();\n    return obj;\n  });\n}\nconst geolocation = {\n  info\n};\nvar __async$1 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst customMessages$1 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction search(_0) {\n  return __async$1(this, arguments, function* (query, options = {}) {\n    var _a;\n    if (typeof query !== \"string\" || query.trim().length === 0) {\n      throw new Error(\"The query must be a non-empty string\");\n    }\n    const endpoint = new URL(`coordinates/search/${query}.json`, defaults.maptilerApiURL);\n    endpoint.searchParams.set(\"key\", (_a = options.apiKey) != null ? _a : config.apiKey);\n    if (\"limit\" in options) {\n      endpoint.searchParams.set(\"limit\", options.limit.toString());\n    }\n    if (\"transformations\" in options) {\n      endpoint.searchParams.set(\"transformations\", options.transformations.toString());\n    }\n    if (\"exports\" in options) {\n      endpoint.searchParams.set(\"exports\", options.exports.toString());\n    }\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, res.status in customMessages$1 ? customMessages$1[res.status] : \"\");\n    }\n    const obj = yield res.json();\n    return obj;\n  });\n}\nfunction transform(_0) {\n  return __async$1(this, arguments, function* (positions, options = {}) {\n    var _a;\n    const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map(coord => `${coord[0]},${coord[1]}`).join(\";\");\n    const endpoint = new URL(`coordinates/transform/${coordinatesStr}.json`, defaults.maptilerApiURL);\n    endpoint.searchParams.set(\"key\", (_a = options.apiKey) != null ? _a : config.apiKey);\n    if (\"sourceCrs\" in options) {\n      endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n    }\n    if (\"targetCrs\" in options) {\n      endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n    }\n    if (\"operations\" in options) {\n      endpoint.searchParams.set(\"ops\", (Array.isArray(options.operations) ? options.operations : [options.operations]).join(\"|\"));\n    }\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, res.status in customMessages$1 ? customMessages$1[res.status] : \"\");\n    }\n    const obj = yield res.json();\n    return obj;\n  });\n}\nconst coordinates = {\n  search,\n  transform\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction get(_0) {\n  return __async(this, arguments, function* (dataId, options = {}) {\n    var _a;\n    if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n      throw new Error(\"The data ID must be a non-empty string\");\n    }\n    const endpoint = new URL(`data/${encodeURIComponent(dataId)}/features.json`, defaults.maptilerApiURL);\n    endpoint.searchParams.set(\"key\", (_a = options.apiKey) != null ? _a : config.apiKey);\n    const urlWithParams = endpoint.toString();\n    const res = yield callFetch(urlWithParams);\n    if (!res.ok) {\n      throw new ServiceError(res, res.status in customMessages ? customMessages[res.status] : \"\");\n    }\n    const obj = yield res.json();\n    return obj;\n  });\n}\nconst data = {\n  get\n};\nfunction expandMapStyle(style) {\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n  return expandedStyle;\n}\nclass MapStyleVariant {\n  constructor(name, variantType, id, referenceStyle, description, imageURL) {\n    this.name = name;\n    this.variantType = variantType;\n    this.id = id;\n    this.referenceStyle = referenceStyle;\n    this.description = description;\n    this.imageURL = imageURL;\n  }\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  getFullName() {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType() {\n    return this.variantType;\n  }\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Get the human-friendly description\n   */\n  getDescription() {\n    return this.description;\n  }\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle() {\n    return this.referenceStyle;\n  }\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return this.referenceStyle.getVariant(variantType);\n  }\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants() {\n    return this.referenceStyle.getVariants().filter(v => v !== this);\n  }\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL() {\n    return this.imageURL;\n  }\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL() {\n    return expandMapStyle(this.getId());\n  }\n}\nclass ReferenceMapStyle {\n  constructor(name, id) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Variants that belong to this reference style, key being the reference type\n     */\n    this.variants = {};\n    /**\n     * Variants that belong to this reference style, ordered by relevance\n     */\n    this.orderedVariants = [];\n  }\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return variantType in this.variants;\n  }\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];\n  }\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants() {\n    return Object.values(this.variants);\n  }\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant() {\n    return this.orderedVariants[0];\n  }\n}\nconst mapStylePresetList = [{\n  referenceStyleID: \"STREETS\",\n  name: \"Streets\",\n  description: \"\",\n  variants: [{\n    id: \"streets-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-night\",\n    name: \"Night\",\n    variantType: \"NIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-pastel\",\n    name: \"Pastel\",\n    variantType: \"PASTEL\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"OUTDOOR\",\n  name: \"Outdoor\",\n  description: \"\",\n  variants: [{\n    id: \"outdoor-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"outdoor-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"WINTER\",\n  name: \"Winter\",\n  description: \"\",\n  variants: [{\n    id: \"winter-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"winter-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"SATELLITE\",\n  name: \"Satellite\",\n  description: \"\",\n  variants: [{\n    id: \"satellite\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"HYBRID\",\n  name: \"Hybrid\",\n  description: \"\",\n  variants: [{\n    id: \"hybrid\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"BASIC\",\n  name: \"Basic\",\n  description: \"\",\n  variants: [{\n    id: \"basic-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"basic-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"basic-v2-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"BRIGHT\",\n  name: \"Bright\",\n  description: \"\",\n  variants: [{\n    id: \"bright-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"bright-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"bright-v2-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"bright-v2-pastel\",\n    name: \"Pastel\",\n    variantType: \"PASTEL\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"OPENSTREETMAP\",\n  name: \"OpenStreetMap\",\n  description: \"\",\n  variants: [{\n    id: \"openstreetmap\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"TOPO\",\n  name: \"Topo\",\n  description: \"\",\n  variants: [{\n    id: \"topo-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-shiny\",\n    name: \"Shiny\",\n    variantType: \"SHINY\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-pastel\",\n    name: \"Pastel\",\n    variantType: \"PASTEL\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-topographique\",\n    name: \"Topographique\",\n    variantType: \"TOPOGRAPHIQUE\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"VOYAGER\",\n  name: \"Voyager\",\n  description: \"\",\n  variants: [{\n    id: \"voyager-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"voyager-v2-darkmatter\",\n    name: \"Darkmatter\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"voyager-v2-positron\",\n    name: \"Positron\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"voyager-v2-vintage\",\n    name: \"Vintage\",\n    variantType: \"VINTAGE\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"TONER\",\n  name: \"Toner\",\n  description: \"\",\n  variants: [{\n    id: \"toner-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"toner-v2-background\",\n    name: \"Background\",\n    variantType: \"BACKGROUND\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"toner-v2-lite\",\n    name: \"Lite\",\n    variantType: \"LITE\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"toner-v2-lines\",\n    name: \"Lines\",\n    variantType: \"LINES\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"DATAVIZ\",\n  name: \"Dataviz\",\n  description: \"\",\n  variants: [{\n    id: \"dataviz\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"dataviz-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"dataviz-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"BACKDROP\",\n  name: \"Backdrop\",\n  description: \"\",\n  variants: [{\n    id: \"backdrop\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"backdrop-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"backdrop-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"OCEAN\",\n  name: \"Ocean\",\n  description: \"\",\n  variants: [{\n    id: \"ocean\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}];\nfunction makeReferenceStyleProxy(referenceStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop)) {\n        return target.getVariant(prop);\n      }\n      if (prop.toString().toUpperCase() === prop) {\n        return referenceStyle.getDefaultVariant();\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction buildMapStyles() {\n  const mapStyle = {};\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n    const refStyle = makeReferenceStyleProxy(new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID));\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(variantInfo.name,\n      // name\n      variantInfo.variantType,\n      // variantType\n      variantInfo.id,\n      // id\n      refStyle,\n      // referenceStyle\n      variantInfo.description, variantInfo.imageURL\n      // imageURL\n      );\n\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle;\n}\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\nconst MapStyle = buildMapStyles();\nfunction getSqSegDist(p, p1, p2) {\n  let x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  let maxSqDist = sqTolerance,\n    index;\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\nfunction simplify(points, tolerance) {\n  if (points.length <= 2) {\n    return points;\n  }\n  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\nfunction staticMapMarkerToString(marker, includeColor = true) {\n  let str = `${marker[0]},${marker[1]}`;\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n  return str;\n}\nfunction simplifyAndStringify(path, maxNbChar = 3e3) {\n  let str = path.map(point => point.join(\",\")).join(\"|\");\n  let tolerance = 5e-6;\n  const toleranceStep = 1e-5;\n  while (str.length > maxNbChar) {\n    const simplerPath = simplify(path, tolerance);\n    str = simplerPath.map(point => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n  return str;\n}\nfunction centered(center, zoom, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = (_a = options.format) != null ? _a : \"png\";\n  let width = ~~((_b = options.width) != null ? _b : 1024);\n  let height = ~~((_c = options.height) != null ? _c : 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = (\"markerIcon\" in options);\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map(m => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${(_d = options.pathFillColor) != null ? _d : \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", (_e = options.apiKey) != null ? _e : config.apiKey);\n  return endpoint.toString();\n}\nfunction bounded(boundingBox, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = (_a = options.format) != null ? _a : \"png\";\n  let width = ~~((_b = options.width) != null ? _b : 1024);\n  let height = ~~((_c = options.height) != null ? _c : 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = (\"markerIcon\" in options);\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map(m => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${(_d = options.pathFillColor) != null ? _d : \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", (_e = options.apiKey) != null ? _e : config.apiKey);\n  return endpoint.toString();\n}\nfunction automatic(options = {}) {\n  var _a, _b, _c, _d, _e;\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\"Automatic static maps require markers and/or path to be created.\");\n  }\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = (_a = options.format) != null ? _a : \"png\";\n  let width = ~~((_b = options.width) != null ? _b : 1024);\n  let height = ~~((_c = options.height) != null ? _c : 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/auto/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = (\"markerIcon\" in options);\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map(m => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${(_d = options.pathFillColor) != null ? _d : \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", (_e = options.apiKey) != null ? _e : config.apiKey);\n  return endpoint.toString();\n}\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic\n};\nexport { ClientConfig, LanguageGeocoding, MapStyle, MapStyleVariant, ReferenceMapStyle, ServiceError, config, coordinates, data, expandMapStyle, geocoding, geolocation, mapStylePresetList, staticMaps };","map":{"version":3,"names":["tryGettingFetch","self","fetch","bind","global","ClientConfig","constructor","_apiKey","_fetch","apiKey","k","f","config","LanguageGeocoding","AUTO","ALBANIAN","ARABIC","ARMENIAN","AZERBAIJANI","BELORUSSIAN","BOSNIAN","BRETON","BULGARIAN","CATALAN","CHINESE","CROATIAN","CZECH","DANISH","DUTCH","ENGLISH","ESPERANTO","ESTONIAN","FINNISH","FRENCH","FRISIAN","GEORGIAN","GERMAN","GREEK","HEBREW","HUNGARIAN","ICELANDIC","IRISH","ITALIAN","JAPANESE","KANNADA","KAZAKH","KOREAN","ROMAN_LATIN","LATVIAN","LITHUANIAN","LUXEMBOURGISH","MACEDONIAN","MALTESE","NORWEGIAN","POLISH","PORTUGUESE","ROMANIAN","ROMANSH","RUSSIAN","SCOTTISH_GAELIC","SERBIAN_CYRILLIC","SLOVAK","SLOVENE","SPANISH","SWEDISH","THAI","TURKISH","UKRAINIAN","WELSH","languageCodeSet","Set","Object","values","getAutoLanguageGeocoding","navigator","Intl","DateTimeFormat","resolvedOptions","locale","split","canditatelangs","Array","from","languages","map","l","filter","has","length","callFetch","_0","__async$4","arguments","resource","options","Error","URL","searchParams","get","trim","defaults","maptilerApiURL","mapStyle","freeze","ServiceError","res","customMessage","url","status","customMessages$3","addLanguageGeocodingOptions","language","isArray","lang","join","set","addCommonForwardAndReverseGeocodingOptions","_a","limit","String","types","addForwardGeocodingOptions","bbox","proximity","country","fuzzyMatch","autocomplete","forward","__async$3","query","endpoint","encodeURIComponent","urlWithParams","toString","ok","obj","json","reverse","position","byId","id","batch","queries","joinedQuery","geocoding","customMessages$2","info","__async$2","geolocation","customMessages$1","search","__async$1","transformations","exports","transform","positions","coordinatesStr","coord","sourceCrs","targetCrs","operations","coordinates","customMessages","__async","dataId","data","expandMapStyle","style","maptilerDomainRegex","match","trimmed","expandedStyle","startsWith","exec","MapStyleVariant","name","variantType","referenceStyle","description","imageURL","getName","getFullName","getType","getId","getDescription","getReferenceStyle","hasVariant","getVariant","getVariants","v","getImageURL","getExpandedStyleURL","ReferenceMapStyle","variants","orderedVariants","addVariant","push","getDefaultVariant","mapStylePresetList","referenceStyleID","makeReferenceStyleProxy","Proxy","target","prop","receiver","toUpperCase","Reflect","buildMapStyles","i","refStyleInfo","refStyle","j","variantInfo","variant","styleToStyle","MapStyle","toLowerCase","getSqSegDist","p","p1","p2","x","y","dx","dy","t","simplifyDPStep","points","first","last","sqTolerance","simplified","maxSqDist","index","sqDist","simplifyDouglasPeucker","simplify","tolerance","simplePoints","staticMapMarkerToString","marker","includeColor","str","simplifyAndStringify","path","maxNbChar","point","toleranceStep","simplerPath","centered","center","zoom","_b","_c","_d","_e","scale","hiDPI","format","width","height","attribution","markerStr","hasIcon","markerIcon","markerAnchor","markerList","markers","m","pathStr","pathFillColor","pathStrokeColor","pathWidth","bounded","boundingBox","padding","automatic","staticMaps"],"sources":["C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\config.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\language.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\callFetch.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\defaults.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\services\\ServiceError.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\services\\geocoding.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\services\\geolocation.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\services\\coordinates.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\services\\data.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\mapstyle.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\services\\simplify.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\client\\src\\services\\staticMaps.ts"],"sourcesContent":["export type FetchFunction = (url: string, options: object) => Promise<any>;\n\nfunction tryGettingFetch() {\n  // this is browser, fetch exists\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n\n  return null;\n}\n\n/**\n * The configuration object definition\n */\nclass ClientConfig {\n  /**\n   * MapTiler Cloud API key\n   */\n  private _apiKey = \"\";\n\n  /**\n   * The fetch function. To be set if in Node < 18, otherwise\n   * will be automatically resolved.\n   */\n  private _fetch: FetchFunction | null = tryGettingFetch();\n\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k: string) {\n    this._apiKey = k;\n  }\n\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey(): string {\n    return this._apiKey;\n  }\n\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f: FetchFunction) {\n    this._fetch = f;\n  }\n\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch(): FetchFunction | null {\n    return this._fetch;\n  }\n}\n\n/**\n * Configuration object\n */\nconst config = new ClientConfig();\n\nexport { ClientConfig, config };\n","/**\n * Languages. Note that not all the languages of this list are available but the compatibility list may be expanded in the future.\n */\nconst LanguageGeocoding = {\n  AUTO: \"auto\",\n  ALBANIAN: \"sq\",\n  ARABIC: \"ar\",\n  ARMENIAN: \"hy\",\n  AZERBAIJANI: \"az\",\n  BELORUSSIAN: \"be\",\n  BOSNIAN: \"bs\",\n  BRETON: \"br\",\n  BULGARIAN: \"bg\",\n  CATALAN: \"ca\",\n  CHINESE: \"zh\",\n  CROATIAN: \"hr\",\n  CZECH: \"cs\",\n  DANISH: \"da\",\n  DUTCH: \"nl\",\n  ENGLISH: \"en\",\n  ESPERANTO: \"eo\",\n  ESTONIAN: \"et\",\n  FINNISH: \"fi\",\n  FRENCH: \"fr\",\n  FRISIAN: \"fy\",\n  GEORGIAN: \"ka\",\n  GERMAN: \"de\",\n  GREEK: \"el\",\n  HEBREW: \"he\",\n  HUNGARIAN: \"hu\",\n  ICELANDIC: \"is\",\n  IRISH: \"ga\",\n  ITALIAN: \"it\",\n  JAPANESE: \"ja\",\n  KANNADA: \"kn\",\n  KAZAKH: \"kk\",\n  KOREAN: \"ko\",\n  ROMAN_LATIN: \"la\",\n  LATVIAN: \"lv\",\n  LITHUANIAN: \"lt\",\n  LUXEMBOURGISH: \"lb\",\n  MACEDONIAN: \"mk\",\n  MALTESE: \"mt\",\n  NORWEGIAN: \"no\",\n  POLISH: \"pl\",\n  PORTUGUESE: \"pt\",\n  ROMANIAN: \"ro\",\n  ROMANSH: \"rm\",\n  RUSSIAN: \"ru\",\n  SCOTTISH_GAELIC: \"gd\",\n  SERBIAN_CYRILLIC: \"sr\",\n  SLOVAK: \"sk\",\n  SLOVENE: \"sl\",\n  SPANISH: \"es\",\n  SWEDISH: \"sv\",\n  THAI: \"th\",\n  TURKISH: \"tr\",\n  UKRAINIAN: \"uk\",\n  WELSH: \"cy\",\n};\n\nconst languageCodeSet = new Set(Object.values(LanguageGeocoding));\n\ntype Values<T> = T[keyof T];\n\n/**\n * Built-in languages values as strings\n */\ntype LanguageGeocodingString = Values<typeof LanguageGeocoding>;\n\nfunction getAutoLanguageGeocoding(): LanguageGeocodingString {\n  if (typeof navigator === \"undefined\") {\n    return Intl.DateTimeFormat()\n      .resolvedOptions()\n      .locale.split(\"-\")[0] as LanguageGeocodingString;\n  }\n\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0]))\n  ).filter((l) => languageCodeSet.has(l as LanguageGeocodingString));\n\n  return canditatelangs.length\n    ? (canditatelangs[0] as LanguageGeocodingString)\n    : LanguageGeocoding.ENGLISH;\n}\n\nexport { LanguageGeocoding, LanguageGeocodingString, getAutoLanguageGeocoding };\n","import { config } from \"./config\";\n\nexport async function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\n      \"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\"\n    );\n  }\n\n  //  Control if URL contains the api key\n  if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n    throw new Error(\n      \"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\"\n    );\n  }\n\n  return config.fetch(resource, options);\n}\n","/**\n * Some default settings for the SDK\n */\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\",\n};\n\nObject.freeze(defaults);\n\nexport { defaults };\n","/**\n * A ServiceError is an Error that includes the HTTP response details\n */\nexport class ServiceError extends Error {\n  constructor(public res: Response, customMessage = \"\") {\n    super(\n      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`\n    );\n  }\n}\n","import { BBox, Feature, Geometry, Position } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\n\nimport {\n  getAutoLanguageGeocoding,\n  LanguageGeocoding,\n  LanguageGeocodingString,\n} from \"../language\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\",\n};\n\nexport type LanguageGeocodingOptions = {\n  /**\n   * Prefer results in specific language. Itâ€™s possible to specify multiple values.\n   */\n  language?: LanguageGeocodingString | Array<LanguageGeocodingString>;\n};\n\nexport type CommonForwardAndReverseGeocodingOptions =\n  LanguageGeocodingOptions & {\n    /**\n     * Custom MapTiler Cloud API key to use instead of the one in global `config`\n     */\n    apiKey?: string;\n\n    /**\n     * Maximum number of results to show. Must be between 1 and 10. Default is 5 for forward and 1 for reverse geocoding.\n     */\n    limit?: number;\n\n    /**\n     * Filter of feature types to return. If not specified, all available feature types are returned.\n     */\n    types?: (\n      | \"country\"\n      | \"region\"\n      | \"subregion\"\n      | \"county\"\n      | \"joint_municipality\"\n      | \"joint_submunicipality\"\n      | \"municipality\"\n      | \"municipal_district\"\n      | \"locality\"\n      | \"neighbourhood\"\n      | \"place\"\n      | \"postal_code\"\n      | \"address\"\n      | \"poi\"\n    )[];\n  };\n\nexport type GeocodingOptions = CommonForwardAndReverseGeocodingOptions & {\n  /**\n   * Only search for results in the specified area.\n   */\n  bbox?: BBox;\n\n  /**\n   * Prefer results close to a specific location.\n   */\n  proximity?: Position;\n\n  /**\n   * Limit search to specific country/countries specified as list of Alpha-2 ISO 3166-1 codes.\n   */\n  country?: string[];\n\n  /**\n   * Set to `false` to disable fuzzy (typo-tolerant) search. Default is `true`.\n   */\n  fuzzyMatch?: boolean;\n\n  /**\n   * Set to `true` to use autocomplete, `false` to disable it.\n   * Default (`undefined`) is to combine autocomplete with non-autocomplete results.\n   */\n  autocomplete?: boolean;\n};\n\nexport type ReverseGeocodingOptions = CommonForwardAndReverseGeocodingOptions;\n\nexport type ByIdGeocodingOptions = LanguageGeocodingOptions;\n\nexport type Coordinates = Position;\n\ntype FeatureProperties = {\n  /**\n   * External reference of the feature used for debugging purposes\n   */\n  ref: string;\n\n  /**\n   * ISO 3166-1 alpha-2 country code of the feature\n   */\n  country_code: string;\n\n  /**\n   * (experimental) Kind of the feature\n   */\n  kind?:\n    | \"road\"\n    | \"road_relation\"\n    | \"admin_area\"\n    | \"place\"\n    | \"street\"\n    | \"virtual_street\";\n\n  /**\n   * (experimental) Value of place=* tag from OpenStreetMap feature if kind=place\n   */\n  \"osm:place_type\"?: string;\n\n  /**\n   * (experimental) Feature tags from OpenStreetMap. Only available for `poi` type.\n   */\n  \"osm:tags\"?: Record<string, string>;\n\n  /**\n   * Array of POI categories. Only available for `poi` type.\n   */\n  categories?: string[];\n};\n\ntype FeatureBase = {\n  /**\n   * Unique feature ID\n   */\n  id: string;\n\n  /**\n   * Localized feature name\n   */\n  text: string;\n\n  /**\n   * Query's primary ISO 639-1 language code\n   */\n  language?: string;\n\n  /**\n   * A string analogous to the `text` field that matches the query in the requested language.\n   * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n   */\n  [text: `text_${string}`]: string;\n\n  /**\n   * A ISO 639-1 query's fallback language code.\n   * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n   */\n  [language: `language_${string}`]: string;\n};\n\nexport type FeatureHierarchy = FeatureProperties & FeatureBase;\n\nexport type GeocodingFeature = Feature<Geometry, FeatureProperties> &\n  FeatureBase & {\n    /**\n     * Bounding box of the original feature as [w, s, e, n] array\n     */\n    bbox: BBox;\n\n    /**\n     * A [lon, lat] array of the original feature centeroid\n     */\n    center: Coordinates;\n\n    /**\n     * Formatted (including the hierarchy) and localized feature full name\n     */\n    place_name: string;\n\n    /**\n     * A string analogous to the `place_name` field that matches the query in the requested language.\n     * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n     */\n    [key: `place_name_${string}`]: string;\n\n    /**\n     * An array of feature types describing the feature.\n     * Currently each feature has only single type but this may change in the future.\n     */\n    place_type: string[];\n\n    /**\n     * Localized type of the place name, matches `place_type` property\n     */\n    place_type_name: string[];\n\n    /**\n     * Feature hierarchy\n     */\n    context?: Array<FeatureHierarchy>;\n\n    /**\n     * Address number, if applicable\n     */\n    address?: string;\n\n    /**\n     * Indicates how well the returned feature matches the user's query on a scale from 0 to 1.\n     * 0 means the result does not match the query text at all, while 1 means the result fully matches the query text.\n     * You can use the relevance property to remove results that don't fully match the query.\n     */\n    relevance: number;\n  };\n\nexport type GeocodingSearchResult = {\n  type: \"FeatureCollection\";\n\n  /**\n   * Array of features found\n   */\n  features: Array<GeocodingFeature>;\n\n  /**\n   * Tokenized search query\n   */\n  query: Array<string>;\n\n  /**\n   * Attribution of the result\n   */\n  attribution: string;\n};\n\nfunction addLanguageGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: LanguageGeocodingOptions\n) {\n  if (options.language == undefined) {\n    return;\n  }\n\n  const languages = Array.from(\n    new Set(\n      (Array.isArray(options.language)\n        ? options.language\n        : [options.language]\n      ).map((lang) =>\n        lang === LanguageGeocoding.AUTO ? getAutoLanguageGeocoding() : lang\n      )\n    )\n  ).join(\",\");\n\n  searchParams.set(\"language\", languages);\n}\n\nfunction addCommonForwardAndReverseGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: CommonForwardAndReverseGeocodingOptions\n) {\n  searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (options.limit != undefined) {\n    searchParams.set(\"limit\", String(options.limit));\n  }\n\n  if (options.types != undefined) {\n    searchParams.set(\"types\", options.types.join(\",\"));\n  }\n\n  addLanguageGeocodingOptions(searchParams, options);\n}\n\nfunction addForwardGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: GeocodingOptions\n) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n\n  if (options.bbox != undefined) {\n    searchParams.set(\"bbox\", options.bbox.join(\",\"));\n  }\n\n  if (options.proximity != undefined) {\n    searchParams.set(\"proximity\", options.proximity.join(\",\"));\n  }\n\n  if (options.country != undefined) {\n    searchParams.set(\"country\", options.country.join(\",\"));\n  }\n\n  if (options.fuzzyMatch != undefined) {\n    searchParams.set(\"fuzzyMatch\", options.fuzzyMatch ? \"true\" : \"false\");\n  }\n\n  if (options.autocomplete != undefined) {\n    searchParams.set(\"autocomplete\", options.autocomplete ? \"true\" : \"false\");\n  }\n}\n\n/**\n * Performs a forward geocoding query to MapTiler API.\n * Providing a human readable place name (of a city, country, street, etc.), the function returns\n * a list of candidate locations including longitude and latitude.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-name-forward\n * @param query\n * @param options\n * @returns\n */\nasync function forward(\n  query: string,\n  options: GeocodingOptions = {}\n): Promise<GeocodingSearchResult> {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `geocoding/${encodeURIComponent(query)}.json`,\n    defaults.maptilerApiURL\n  );\n\n  const { searchParams } = endpoint;\n\n  addForwardGeocodingOptions(searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a reverse geocoding query to MapTiler API.\n * Providing a longitude and latitude, this function returns a set of human readable information about this place (country, city, street, etc.)\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-coordinates-reverse\n * @param position\n * @param options\n * @returns\n */\nasync function reverse(\n  position: Position,\n  options: ReverseGeocodingOptions = {}\n): Promise<GeocodingSearchResult> {\n  if (!Array.isArray(position) || position.length < 2) {\n    throw new Error(\"The position must be an array of form [lng, lat].\");\n  }\n\n  const endpoint = new URL(\n    `geocoding/${position[0]},${position[1]}.json`,\n    defaults.maptilerApiURL\n  );\n\n  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a geocoding query to MapTiler API to obtain fature by its ID.\n * Providing a feature ID, this function returns a feature which includes its full geometry.\n * Note that the feature ID is not stable and it changes when the database is re-indexed.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-feature-id\n * @param id\n * @param options\n * @returns\n */\nasync function byId(\n  id: string,\n  options: ByIdGeocodingOptions = {}\n): Promise<GeocodingSearchResult> {\n  const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n\n  addLanguageGeocodingOptions(endpoint.searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a batch geocoding query to MapTiler API.\n * Provide multiple queries in the array. Each query can be forward, reverse or by feature ID.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#batch-geocoding\n * @param queries\n * @param options\n * @returns\n */\nasync function batch(\n  queries: string[],\n  options: GeocodingOptions = {}\n): Promise<GeocodingSearchResult[]> {\n  if (!queries.length) {\n    return [];\n  }\n\n  const joinedQuery = queries\n    .map((query) => encodeURIComponent(query))\n    .join(\";\");\n\n  const endpoint = new URL(\n    `geocoding/${joinedQuery}.json`,\n    defaults.maptilerApiURL\n  );\n\n  const { searchParams } = endpoint;\n\n  addForwardGeocodingOptions(searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj = await res.json();\n\n  return queries.length === 1 ? [obj] : obj;\n}\n\n/**\n * The **geocoding** namespace contains asynchronous functions to call the [MapTiler Geocoding API](https://docs.maptiler.com/cloud/api/geocoding/).\n * The **Geocoding API** provides ways to get geographic coordinates from a human-readable search query of a place (forward geocoding)\n * and to get the location details (country, city, street, etc.) from a geographic coordinate (reverse geocoding);\n */\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch,\n  language: LanguageGeocoding,\n};\n\nexport { geocoding };\n","import { BBox } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Options that can be provided to get user data.\n */\nexport type GeolocationInfoOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n};\n\nexport type GeolocationResult = {\n  /**\n   * Name of the country\n   * Example: Switzerland\n   */\n  country?: string;\n\n  /**\n   * Two-letter code of the country ISO 3166-1 alpha-2 codes\n   * Example: CH\n   */\n  country_code?: string;\n\n  /**\n   * Bounds of the country in WGS84 degrees [west, south, east, north].\n   * Example: [5.95538,45.818852,10.490936,47.809357]\n   */\n  country_bounds?: BBox;\n\n  /**\n   * Official country languages in ISO 639-1 format. ISO 639-1 codes\n   * Example: [\"de\",\"fr\",\"it\"]\n   */\n  country_languages?: Array<string>;\n\n  /**\n   * Name of the continent\n   * Example: Europe\n   */\n  continent?: string;\n\n  /**\n   * Two-letter code of the continent\n   * Example: EU\n   */\n  continent_code?: string;\n\n  /**\n   * Indicated whether the country is part of the European Union.\n   */\n  eu?: boolean;\n\n  /**\n   * Name of the city\n   * Example: Zurich\n   */\n  city?: string;\n\n  /**\n   * Latitude of the location\n   * Example: 47.36667\n   */\n  latitude?: number;\n\n  /**\n   * Longitude of the location\n   * Example: 8.55\n   */\n  longitude?: number;\n\n  /**\n   * Postal code\n   * Example: 8000\n   */\n  postal?: string;\n\n  /**\n   * If known, the ISO 3166-2 name for the first level region. ISO 3166-2 codes\n   * Example: Zurich\n   */\n  region?: string;\n\n  /**\n   * If known, the ISO 3166-2 code for the first level region. ISO 3166-2 codes\n   * Example: ZH\n   */\n  region_code?: string;\n\n  /**\n   * Name of the timezone\n   * Example: Europe/Zurich\n   */\n  timezone?: string;\n};\n\n/**\n * Looks up geolocation details from IP address using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geolocation/#ip-geolocation\n * @returns\n */\nasync function info(\n  options: GeolocationInfoOptions = {}\n): Promise<GeolocationResult> {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj as GeolocationResult;\n}\n\n/**\n * The **geolocation** namespace contains an asynchronous function to call the [MapTiler Geolocation API](https://docs.maptiler.com/cloud/api/geolocation/).\n * The **Geolocation API** provides a way to retrieve the IP address as well as geographic informations of a machine performing the query (most likely: a user)\n */\nconst geolocation = {\n  info,\n};\n\nexport { geolocation };\n","import { BBox, Position } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\nexport type CoordinatesSearchOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Maximum number of results returned (default: 10)\n   */\n  limit?: number;\n\n  /**\n   *  Show detailed transformations for each CRS (default: false)\n   */\n  transformations?: boolean;\n\n  /**\n   * Show exports in WKT and Proj4 notations (default: false)\n   */\n  exports?: boolean;\n};\n\nexport type CoordinateId = {\n  authority: string;\n  code: BigInteger;\n};\n\nexport type CoordinateExport = {\n  proj4: string;\n  wkt: string;\n};\n\nexport type CoordinateGrid = {\n  path: string;\n};\n\nexport type CoordinateTransformation = {\n  id: CoordinateId;\n  name: string;\n  reversible: boolean;\n  usable: boolean;\n  deprecated: boolean;\n  grids: Array<CoordinateGrid>;\n  accuracy?: number;\n  area?: string;\n  bbox?: BBox;\n  target_crs?: CoordinateId;\n  unit?: string;\n};\n\nexport type CoordinateSearch = {\n  id: CoordinateId;\n\n  name: string;\n\n  kind: string;\n\n  deprecated: boolean;\n\n  transformations?: Array<CoordinateTransformation | number>;\n\n  accuracy?: number;\n\n  unit?: string;\n\n  area?: string;\n\n  /**\n   * Bounding box of the resource in [min_lon, min_lat, max_lon, max_lat] order.\n   */\n  bbox?: BBox;\n\n  /**\n   * Most suitable transformation for this CRS.\n   */\n  default_transformation?: any;\n\n  exports: CoordinateExport;\n};\n\nexport type CoordinateSearchResult = {\n  /**\n   * The coordinate search results\n   */\n  results: Array<CoordinateSearch>;\n\n  /**\n   * The number of results\n   */\n  total: number;\n};\n\n/**\n * Search information about coordinate systems using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#search-coordinate-systems\n * @param query Can be any kind of CRS by name or code\n * @param options\n * @returns\n */\nasync function search(\n  query: string,\n  options: CoordinatesSearchOptions = {}\n): Promise<CoordinateSearchResult> {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `coordinates/search/${query}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\n      \"transformations\",\n      options.transformations.toString()\n    );\n  }\n\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj as CoordinateSearchResult;\n}\n\nexport type XYZ = {\n  x?: number;\n  y?: number;\n  z?: number;\n};\n\nexport type CoordinateTransformResult = {\n  results: Array<XYZ>;\n\n  /**\n   * Transformations are selected using given ops parameter.\n   * If no parameter is given, auto strategy is used.\n   * If given, it may try to use a listed transformation,\n   * then fallback to towgs84 patching, and finally boundcrs.\n   */\n  transformer_selection_strategy: string;\n};\n\n/**\n * Options that can be provided when transforming a coordinate from one CRS to another.\n */\nexport type CoordinatesTransformOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Source coordinate reference system (default: 4326)\n   */\n  sourceCrs?: number;\n\n  /**\n   * Target coordinate reference system (default: 4326)\n   */\n  targetCrs?: number;\n\n  /**\n   * List of codes of operations\n   */\n  operations?: number | Array<number>;\n};\n\n/**\n * Transforms coordinates from a source reference system to a target reference system using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#transform-coordinates\n * @param positions\n * @param options\n * @returns\n */\nasync function transform(\n  positions: Position | Array<Position>,\n  options: CoordinatesTransformOptions = {}\n): Promise<CoordinateTransformResult> {\n  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions])\n    .map((coord) => `${coord[0]},${coord[1]}`)\n    .join(\";\");\n\n  const endpoint = new URL(\n    `coordinates/transform/${coordinatesStr}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\n      \"ops\",\n      (Array.isArray(options.operations)\n        ? options.operations\n        : [options.operations]\n      ).join(\"|\")\n    );\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj as CoordinateTransformResult;\n}\n\n/**\n * The **coordinate** namespace contains asynchronous functions to call the [MapTiler Coordinate API](https://docs.maptiler.com/cloud/api/coordinates/).\n * The goal of the **Coordinate API* is query information about spatial coordinate reference system (CRS) as well as to transform coordinates from one CRS to another.\n */\nconst coordinates = {\n  search,\n  transform,\n};\n\nexport { coordinates };\n","import { FeatureCollection } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Options that can be provided to get user data.\n */\nexport type GetDataOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n};\n\n/**\n * Get user data and returns it as GeoJSON using the MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/data/#geojson\n * @param dataId\n * @returns\n */\nasync function get(\n  dataId: string,\n  options: GetDataOptions = {}\n): Promise<FeatureCollection> {\n  if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n    throw new Error(\"The data ID must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `data/${encodeURIComponent(dataId)}/features.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * The **data** namespace contains an asynchronous function to call the [MapTiler Data API](https://docs.maptiler.com/cloud/api/data/).\n * The **Data API** provides a way to retrieve user data in GeoJSON format.\n */\nconst data = {\n  get,\n};\n\nexport { data };\n","/**\n * Expand the map style provided as argument of the Map constructor\n * @param style\n * @returns\n */\nexport function expandMapStyle(style): string {\n  // testing if the style provided is of form \"maptiler://some-style\"\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n\n  // The style was possibly already given as expanded URL\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    // The style could also possibly just be the name of the style without any URI style\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n\n  return expandedStyle;\n}\n\n/**\n * Type for object containing style details\n */\nexport type MapStylePreset = {\n  referenceStyleID: string;\n  name: string;\n  description: string;\n  variants: Array<{\n    id: string;\n    name: string;\n    variantType: string;\n    description: string;\n    imageURL: string;\n  }>;\n};\n\n/**\n * An instance of MapStyleVariant contains information about a style to use that belong to a reference style\n */\nexport class MapStyleVariant {\n  constructor(\n    /**\n     * Human-friendly name\n     */\n    private name: string,\n\n    /**\n     * Variant name the variant is addressed to from its reference style: `MapStyle.REFERNCE_STYLE_NAME.VARIANT_TYPE`\n     */\n    private variantType: string,\n\n    /**\n     * MapTiler Cloud id\n     */\n    private id: string,\n\n    /**\n     * Reference map style, used to retrieve sibling variants\n     */\n    private referenceStyle: ReferenceMapStyle,\n\n    /**\n     * Human-friendly description\n     */\n    private description: string,\n\n    /**\n     * URL to an image describing the style variant\n     */\n    private imageURL: string\n  ) {}\n\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  getFullName(): string {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType(): string {\n    return this.variantType;\n  }\n\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Get the human-friendly description\n   */\n  getDescription(): string {\n    return this.description;\n  }\n\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle(): ReferenceMapStyle {\n    return this.referenceStyle;\n  }\n\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType: string): boolean {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType: string): MapStyleVariant {\n    return this.referenceStyle.getVariant(variantType);\n  }\n\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants(): Array<MapStyleVariant> {\n    return this.referenceStyle.getVariants().filter((v) => v !== this);\n  }\n\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL(): string {\n    return this.imageURL;\n  }\n\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL(): string {\n    return expandMapStyle(this.getId());\n  }\n}\n\n/**\n * An instance of reference style contains a list of StyleVariants ordered by relevance\n */\nexport class ReferenceMapStyle {\n  /**\n   * Variants that belong to this reference style, key being the reference type\n   */\n  private variants: { [key: string]: MapStyleVariant } = {};\n\n  /**\n   * Variants that belong to this reference style, ordered by relevance\n   */\n  private orderedVariants: Array<MapStyleVariant> = [];\n\n  constructor(\n    /**\n     * Human-friendly name of this reference style\n     */\n    private name: string,\n\n    /**\n     * ID of this reference style\n     */\n    private id: string\n  ) {}\n\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v: MapStyleVariant) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType: string): boolean {\n    return variantType in this.variants;\n  }\n\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType: string): MapStyleVariant {\n    return variantType in this.variants\n      ? this.variants[variantType]\n      : this.orderedVariants[0];\n  }\n\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants(): Array<MapStyleVariant> {\n    return Object.values(this.variants);\n  }\n\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant(): MapStyleVariant {\n    return this.orderedVariants[0];\n  }\n}\n\n/**\n * All the styles and variants maintained by MapTiler.\n */\nexport type MapStyleType = {\n  /**\n   * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings\n   */\n  STREETS: ReferenceMapStyle & {\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings.\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in dark mode.\n     */\n    DARK: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in light mode.\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in blue night mode.\n     */\n    NIGHT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, with a pastel color palette.\n     */\n    PASTEL: MapStyleVariant;\n  };\n\n  /**\n   * Suitable for outdoor activities. With elevation isolines and hillshading.\n   */\n  OUTDOOR: ReferenceMapStyle & {\n    /**\n     * Suitable for outdoor activities. With elevation isolines and hillshading.\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     * Suitable for outdoor activities. With elevation isolines and hillshading, in dark mode.\n     */\n    DARK: MapStyleVariant;\n  };\n\n  /**\n   * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading.\n   */\n  WINTER: ReferenceMapStyle & {\n    /**\n     * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading.\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading, in dark mode.\n     */\n    DARK: MapStyleVariant;\n  };\n\n  /**\n   * High resolution imagery only, without any label.\n   */\n  SATELLITE: ReferenceMapStyle & {\n    /**\n     * High resolution imagery only, without any label.\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * High resolution imagery with labels, political borders and roads.\n   */\n  HYBRID: ReferenceMapStyle & {\n    /**\n     * High resolution imagery with labels, political borders and roads.\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * A minimalist street-oriented style without POI\n   */\n  BASIC: ReferenceMapStyle & {\n    /**\n     * A minimalist street-oriented style without POI\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A minimalist street-oriented style without POI, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A minimalist street-oriented style without POI, in light mode\n     */\n    LIGHT: MapStyleVariant;\n  };\n\n  /**\n   * A bright street-oriented style, a nice alternative to `streets`\n   */\n  BRIGHT: ReferenceMapStyle & {\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, in light mode\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, with a soft pastel color palette\n     */\n    PASTEL: MapStyleVariant;\n  };\n\n  /**\n   * Classic OpenStreetMap style\n   */\n  OPENSTREETMAP: ReferenceMapStyle & {\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n   */\n  TOPO: ReferenceMapStyle & {\n    /**\n     * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A nice high-contrast, and high saturation alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    SHINY: MapStyleVariant;\n    /**\n     * A nice low-contrast, alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details, using a soft pastel color palette\n     */\n    PASTEL: MapStyleVariant;\n\n    /**\n     * A nice very high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    TOPOGRAPHIQUE: MapStyleVariant;\n  };\n\n  /**\n   * A nice alternative to `streets` with a soft color palette\n   */\n  VOYAGER: ReferenceMapStyle & {\n    /**\n     * A nice alternative to `streets` with a soft color palette\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A nice alternative to `streets`, in very dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A nice alternative to `streets`, in light mode\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * A nice alternative to `streets` with a soft sepia color palette and vintage look\n     */\n    VINTAGE: MapStyleVariant;\n  };\n\n  /**\n   * A bold very high contrast black and white (no gray!) style for the city\n   */\n  TONER: ReferenceMapStyle & {\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city, without any label\n     */\n    BACKGROUND: MapStyleVariant;\n    /**\n     * A bold very high contrast, yet faded, style for the city\n     */\n    LITE: MapStyleVariant;\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city, with no building, only roads!\n     */\n    LINES: MapStyleVariant;\n  };\n\n  /**\n   * Minimalist style, perfect for data visualization\n   */\n  DATAVIZ: ReferenceMapStyle & {\n    /**\n     *  Minimalist style, perfect for data visualization\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     *  Minimalist style, perfect for data visualization in dark mode\n     */\n    DARK: MapStyleVariant;\n\n    /**\n     *  Minimalist style, perfect for data visualization in light mode\n     */\n    LIGHT: MapStyleVariant;\n  };\n\n  /**\n   * Explore deep see trenches and mountains, with isolines and depth labels\n   */\n  OCEAN: ReferenceMapStyle & {\n    /**\n     * Explore deep see trenches and mountains, with isolines and depth labels\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * Neutral greyscale style with hillshading suitable for colorful terrain-aware visualization\n   */\n  BACKDROP: ReferenceMapStyle & {\n    /**\n     *  Neutral greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     *  Dark greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    DARK: MapStyleVariant;\n\n    /**\n     *  Light greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    LIGHT: MapStyleVariant;\n  };\n};\n\nexport const mapStylePresetList: Array<MapStylePreset> = [\n  {\n    referenceStyleID: \"STREETS\",\n    name: \"Streets\",\n    description: \"\",\n    variants: [\n      {\n        id: \"streets-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-night\",\n        name: \"Night\",\n        variantType: \"NIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OUTDOOR\",\n    name: \"Outdoor\",\n    description: \"\",\n    variants: [\n      {\n        id: \"outdoor-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"outdoor-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"WINTER\",\n    name: \"Winter\",\n    description: \"\",\n    variants: [\n      {\n        id: \"winter-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"winter-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"SATELLITE\",\n    name: \"Satellite\",\n    description: \"\",\n    variants: [\n      {\n        id: \"satellite\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"HYBRID\",\n    name: \"Hybrid\",\n    description: \"\",\n    variants: [\n      {\n        id: \"hybrid\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BASIC\",\n    name: \"Basic\",\n    description: \"\",\n    variants: [\n      {\n        id: \"basic-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"basic-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"basic-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BRIGHT\",\n    name: \"Bright\",\n    description: \"\",\n    variants: [\n      {\n        id: \"bright-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OPENSTREETMAP\",\n    name: \"OpenStreetMap\",\n    description: \"\",\n    variants: [\n      {\n        id: \"openstreetmap\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"TOPO\",\n    name: \"Topo\",\n    description: \"\",\n    variants: [\n      {\n        id: \"topo-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-shiny\",\n        name: \"Shiny\",\n        variantType: \"SHINY\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-topographique\",\n        name: \"Topographique\",\n        variantType: \"TOPOGRAPHIQUE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"VOYAGER\",\n    name: \"Voyager\",\n    description: \"\",\n    variants: [\n      {\n        id: \"voyager-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-darkmatter\",\n        name: \"Darkmatter\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-positron\",\n        name: \"Positron\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-vintage\",\n        name: \"Vintage\",\n        variantType: \"VINTAGE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"TONER\",\n    name: \"Toner\",\n    description: \"\",\n    variants: [\n      {\n        id: \"toner-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-background\",\n        name: \"Background\",\n        variantType: \"BACKGROUND\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-lite\",\n        name: \"Lite\",\n        variantType: \"LITE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-lines\",\n        name: \"Lines\",\n        variantType: \"LINES\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"DATAVIZ\",\n    name: \"Dataviz\",\n    description: \"\",\n    variants: [\n      {\n        id: \"dataviz\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"dataviz-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"dataviz-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BACKDROP\",\n    name: \"Backdrop\",\n    description: \"\",\n    variants: [\n      {\n        id: \"backdrop\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"backdrop-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"backdrop-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OCEAN\",\n    name: \"Ocean\",\n    description: \"\",\n    variants: [\n      {\n        id: \"ocean\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n];\n\nfunction makeReferenceStyleProxy(referenceStyle: ReferenceMapStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop as string)) {\n        return target.getVariant(prop as string);\n      }\n\n      // This variant does not exist for this style, but since it's full uppercase\n      // we guess that the dev tries to access a style variant. So instead of\n      // returning the default (STREETS.DEFAULT), we return the non-variant of the current style\n      if (prop.toString().toUpperCase() === (prop as string)) {\n        return referenceStyle.getDefaultVariant();\n      }\n\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\nfunction buildMapStyles(): MapStyleType {\n  const mapStyle = {};\n\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n\n    const refStyle = makeReferenceStyleProxy(\n      new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID)\n    );\n\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(\n        variantInfo.name, // name\n        variantInfo.variantType, // variantType\n        variantInfo.id, // id\n        refStyle, // referenceStyle\n        variantInfo.description,\n        variantInfo.imageURL // imageURL\n      );\n\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle as MapStyleType;\n}\n\nexport function styleToStyle(\n  style: string | ReferenceMapStyle | MapStyleVariant | null | undefined\n): string {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID]\n      .getDefaultVariant()\n      .getId();\n  }\n\n  // If the provided style is a shorthand (eg. \"streets-v2\") then we make sure it's trimmed and lowercase\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\n\n/**\n * Contains all the reference map style created by MapTiler team as well as all the variants.\n * For example, `MapStyle.STREETS` and the variants:\n * - `MapStyle.STREETS.DARK`\n * - `MapStyle.STREETS.LIGHT`\n * - `MapStyle.STREETS.PASTEL`\n *\n */\nexport const MapStyle: MapStyleType = buildMapStyles();\n","/**\\\n * This code is borrowed from https://github.com/mourner/simplify-js and reworked a little.\n */\n\nimport { Position } from \"geojson\";\n\n// square distance from a point to a segment\nfunction getSqSegDist(p: Position, p1: Position, p2: Position): number {\n  let x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n}\n\nfunction simplifyDPStep(\n  points: Array<Position>,\n  first: number,\n  last: number,\n  sqTolerance: number,\n  simplified: Array<Position>\n) {\n  let maxSqDist = sqTolerance,\n    index;\n\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(\n  points: Array<Position>,\n  sqTolerance: number\n): Array<Position> {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nexport default function simplify(\n  points: Array<Position>,\n  tolerance: number\n): Array<Position> {\n  if (points.length <= 2) {\n    return points;\n  }\n\n  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\n","import { BBox, Position } from \"geojson\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { MapStyleVariant, ReferenceMapStyle, styleToStyle } from \"../mapstyle\";\nimport simplify from \"./simplify\";\n\n/**\n * Base set of options that can be provided to all the types of static maps\n */\nexport type StaticMapBaseOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Style of the map (not full style URL). Example: \"winter\", \"streets-v2\".\n   * Default: `\"streets-v2\"`\n   */\n  style?: string | ReferenceMapStyle | MapStyleVariant;\n\n  /**\n   * Double the size of the static map image to support hiDPI/Retina monitors.\n   * Default: `false`\n   */\n  hiDPI?: boolean;\n\n  /**\n   * Image format.\n   * Default: `\"png\"`\n   */\n  format?: \"png\" | \"jpg\" | \"webp\";\n\n  /**\n   * Width of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  width?: number;\n\n  /**\n   * Height of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  height?: number;\n\n  /**\n   * Placement of the attribution. Can also be set to `false` to not show attribution.\n   * Default: `\"bottomright\"`\n   */\n  attribution?: \"bottomright\" | \"bottomleft\" | \"topleft\" | \"topright\" | false;\n\n  /**\n   * A marker or list of markers to show on the map\n   * Default: none provided\n   */\n  markers?: StaticMapMarker | Array<StaticMapMarker>;\n\n  /**\n   * URL of the marker image. Applies only if one or multiple markers positions are provided.\n   * Default: none provided\n   */\n  markerIcon?: string;\n\n  /**\n   * Position of the marker regarding its coordinates. Applies only:\n   * - with a custom icon provided with `markerIcon`\n   * - if one or multiple markers positions are provided.\n   * Default: `\"bottom\"`\n   */\n  markerAnchor?:\n    | \"top\"\n    | \"left\"\n    | \"bottom\"\n    | \"right\"\n    | \"center\"\n    | \"topleft\"\n    | \"bottomleft\"\n    | \"topright\"\n    | \"bottomright\";\n\n  /**\n   * Draw a path or polygon on top of the map. If the path is too long it will be simplified, yet remaining accurate.\n   * Default: none provided\n   */\n  path?: Array<Position>;\n\n  /**\n   * Color of the path line. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: `\"blue\"`\n   */\n  pathStrokeColor?: string;\n\n  /**\n   * Color of the filling, also works if the polygon is not closed. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: none (transparent filling)\n   */\n  pathFillColor?: string;\n\n  /**\n   * Width of the path line in pixel. It can be floating point precision (ex: `0.5`)\n   * Default: `1` if `hiDPI` is `false` and `2` if `hiDPI` is `true`.\n   */\n  pathWidth?: number;\n};\n\n/**\n * Options that can be provided to centered static maps\n */\nexport type CenteredStaticMapOptions = StaticMapBaseOptions;\n\n/**\n * Options that can be provided to bounded static maps\n */\nexport type BoundedStaticMapOptions = StaticMapBaseOptions & {\n  /**\n   * Extra space added around the regio of interest, in percentage.\n   * Default: `0.1` (for 10%)\n   */\n  padding?: number;\n};\n\n/**\n * Options that can be provided to automatic static maps\n */\nexport type AutomaticStaticMapOptions = BoundedStaticMapOptions;\n\n/**\n * Definition of a maker to show on a static map\n */\nexport type StaticMapMarker = [\n  /**\n   * Longitude of the marker\n   */\n  number,\n  /**\n   * latitude of the marker\n   */\n  number,\n  /**\n   * Color of the marker with CSS syntax. Applies only if a custom `markerIcon` is not provided.\n   */\n  string\n];\n\nfunction staticMapMarkerToString(\n  marker: StaticMapMarker,\n  includeColor = true\n): string {\n  let str = `${marker[0]},${marker[1]}`;\n\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n\n  return str;\n}\n\nfunction simplifyAndStringify(path: Array<Position>, maxNbChar = 3000): string {\n  let str = path.map((point) => point.join(\",\")).join(\"|\");\n  let tolerance = 0.000005;\n  const toleranceStep = 0.00001;\n\n  while (str.length > maxNbChar) {\n    const simplerPath = simplify(path, tolerance);\n    // str = simplerPath.map(point => point.join(',')).join('|');\n    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n\n  return str;\n}\n\n/**\n * Construct the URL for a static map centered on one point.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param center\n * @param zoom\n * @param options\n * @returns\n */\nfunction centered(\n  center: Position,\n  zoom: number,\n  options: CenteredStaticMapOptions = {}\n): string {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${center[0]},${\n      center[1]\n    },${zoom}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map using a bounding box\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param boundingBox\n * @param options\n * @returns\n */\nfunction bounded(\n  boundingBox: BBox,\n  options: BoundedStaticMapOptions = {}\n): string {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${\n      boundingBox[1]\n    },${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map automatically fitted around the provided path or markers.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param options\n * @returns\n */\nfunction automatic(options: AutomaticStaticMapOptions = {}): string {\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\n      \"Automatic static maps require markers and/or path to be created.\"\n    );\n  }\n\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(\n      style\n    )}/static/auto/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * The **staticMaps** namespace contains an synchronous function build image URL of static map, as specified by the [MapTiler Static Map API](https://docs.maptiler.com/cloud/api/static-maps/).\n * The URL of static maps can then be used within a `<img />` markup element, as the `src` property value.\n */\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic,\n};\n\nexport { staticMaps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}