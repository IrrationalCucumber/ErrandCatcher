{"ast":null,"code":"import maplibregl__default from 'maplibre-gl';\nexport * from 'maplibre-gl';\nimport { Base64 } from 'js-base64';\nimport EventEmitter from 'events';\nimport { config as config$1, MapStyle, mapStylePresetList, expandMapStyle, MapStyleVariant, ReferenceMapStyle, geolocation } from '@maptiler/client';\nexport { LanguageGeocoding, MapStyle, MapStyleVariant, ReferenceMapStyle, ServiceError, coordinates, data, geocoding, geolocation, staticMaps } from '@maptiler/client';\nimport { v4 } from 'uuid';\nconst Language = {\n  /**\n   * AUTO mode uses the language of the browser\n   */\n  AUTO: \"auto\",\n  /**\n   * STYLE is a custom flag to keep the language of the map as defined into the style.\n   * If STYLE is set in the constructor, then further modification of the language\n   * with `.setLanguage()` is not possible.\n   */\n  STYLE_LOCK: \"style_lock\",\n  /**\n   * Default fallback languages that uses latin charaters\n   */\n  LATIN: \"latin\",\n  /**\n   * Default fallback languages that uses non-latin charaters\n   */\n  NON_LATIN: \"nonlatin\",\n  /**\n   * Labels are in their local language, when available\n   */\n  LOCAL: \"\",\n  ALBANIAN: \"sq\",\n  AMHARIC: \"am\",\n  ARABIC: \"ar\",\n  ARMENIAN: \"hy\",\n  AZERBAIJANI: \"az\",\n  BASQUE: \"eu\",\n  BELORUSSIAN: \"be\",\n  BOSNIAN: \"bs\",\n  BRETON: \"br\",\n  BULGARIAN: \"bg\",\n  CATALAN: \"ca\",\n  CHINESE: \"zh\",\n  CORSICAN: \"co\",\n  CROATIAN: \"hr\",\n  CZECH: \"cs\",\n  DANISH: \"da\",\n  DUTCH: \"nl\",\n  ENGLISH: \"en\",\n  ESPERANTO: \"eo\",\n  ESTONIAN: \"et\",\n  FINNISH: \"fi\",\n  FRENCH: \"fr\",\n  FRISIAN: \"fy\",\n  GEORGIAN: \"ka\",\n  GERMAN: \"de\",\n  GREEK: \"el\",\n  HEBREW: \"he\",\n  HINDI: \"hi\",\n  HUNGARIAN: \"hu\",\n  ICELANDIC: \"is\",\n  INDONESIAN: \"id\",\n  IRISH: \"ga\",\n  ITALIAN: \"it\",\n  JAPANESE: \"ja\",\n  JAPANESE_HIRAGANA: \"ja-Hira\",\n  JAPANESE_KANA: \"ja_kana\",\n  JAPANESE_LATIN: \"ja_rm\",\n  JAPANESE_2018: \"ja-Latn\",\n  KANNADA: \"kn\",\n  KAZAKH: \"kk\",\n  KOREAN: \"ko\",\n  KOREAN_LATIN: \"ko-Latn\",\n  KURDISH: \"ku\",\n  ROMAN_LATIN: \"la\",\n  LATVIAN: \"lv\",\n  LITHUANIAN: \"lt\",\n  LUXEMBOURGISH: \"lb\",\n  MACEDONIAN: \"mk\",\n  MALAYALAM: \"ml\",\n  MALTESE: \"mt\",\n  NORWEGIAN: \"no\",\n  OCCITAN: \"oc\",\n  POLISH: \"pl\",\n  PORTUGUESE: \"pt\",\n  ROMANIAN: \"ro\",\n  ROMANSH: \"rm\",\n  RUSSIAN: \"ru\",\n  SCOTTISH_GAELIC: \"gd\",\n  SERBIAN_CYRILLIC: \"sr\",\n  SERBIAN_LATIN: \"sr-Latn\",\n  SLOVAK: \"sk\",\n  SLOVENE: \"sl\",\n  SPANISH: \"es\",\n  SWEDISH: \"sv\",\n  TAMIL: \"ta\",\n  TELUGU: \"te\",\n  THAI: \"th\",\n  TURKISH: \"tr\",\n  UKRAINIAN: \"uk\",\n  WELSH: \"cy\"\n};\nconst languagesIsoSet = new Set(Object.values(Language));\nfunction isLanguageSupported(lang) {\n  return languagesIsoSet.has(lang);\n}\nconst languageCodeSet = new Set(Object.values(Language));\nfunction getBrowserLanguage() {\n  if (typeof navigator === \"undefined\") {\n    return Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n  }\n  const canditatelangs = Array.from(new Set(navigator.languages.map(l => l.split(\"-\")[0]))).filter(l => languageCodeSet.has(l));\n  return canditatelangs.length ? canditatelangs[0] : Language.LATIN;\n}\nconst MAPTILER_SESSION_ID = v4();\nclass SdkConfig extends EventEmitter {\n  constructor() {\n    super();\n    /**\n     * The primary language. By default, the language of the web browser is used.\n     */\n    this.primaryLanguage = Language.AUTO;\n    /**\n     * The secondary language, to overwrite the default language defined in the map style.\n     * This settings is highly dependant on the style compatibility and may not work in most cases.\n     */\n    this.secondaryLanguage = null;\n    /**\n     * Setting on whether of not the SDK runs with a session logic.\n     * A \"session\" is started at the initialization of the SDK and finished when the browser\n     * page is being refreshed.\n     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n     * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n     */\n    this.session = true;\n    /**\n     * Unit to be used\n     */\n    this._unit = \"metric\";\n    /**\n     * MapTiler Cloud API key\n     */\n    this._apiKey = \"\";\n  }\n  /**\n   * Set the unit system\n   */\n  set unit(u) {\n    this._unit = u;\n    this.emit(\"unit\", u);\n  }\n  /**\n   * Get the unit system\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n    config$1.apiKey = k;\n    this.emit(\"apiKey\", k);\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    config$1.fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return config$1.fetch;\n  }\n}\nconst config = new SdkConfig();\nconst defaults = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: Language.AUTO,\n  secondaryLanguage: Language.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\"\n};\nObject.freeze(defaults);\nclass LogoControl extends maplibregl__default.LogoControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nclass MaptilerLogoControl extends LogoControl {\n  constructor(options = {}) {\n    var _a, _b;\n    super(options);\n    this.logoURL = \"\";\n    this.linkURL = \"\";\n    this.logoURL = (_a = options.logoURL) != null ? _a : defaults.maptilerLogoURL;\n    this.linkURL = (_b = options.linkURL) != null ? _b : defaults.maptilerURL;\n  }\n  onAdd(map) {\n    this._map = map;\n    this._compact = this.options && this.options.compact;\n    this._container = window.document.createElement(\"div\");\n    this._container.className = \"maplibregl-ctrl\";\n    const anchor = window.document.createElement(\"a\");\n    anchor.style.backgroundRepeat = \"no-repeat\";\n    anchor.style.cursor = \"pointer\";\n    anchor.style.display = \"block\";\n    anchor.style.height = \"23px\";\n    anchor.style.margin = \"0 0 -4px -4px\";\n    anchor.style.overflow = \"hidden\";\n    anchor.style.width = \"88px\";\n    anchor.style.backgroundImage = `url(${this.logoURL})`;\n    anchor.style.backgroundSize = \"100px 30px\";\n    anchor.style.width = \"100px\";\n    anchor.style.height = \"30px\";\n    anchor.target = \"_blank\";\n    anchor.rel = \"noopener\";\n    anchor.href = this.linkURL;\n    anchor.setAttribute(\"aria-label\", \"MapTiler logo\");\n    anchor.setAttribute(\"rel\", \"noopener\");\n    this._container.appendChild(anchor);\n    this._container.style.display = \"block\";\n    this._map.on(\"resize\", this._updateCompact);\n    this._updateCompact();\n    return this._container;\n  }\n}\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) {\n    if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  }\n  return a;\n};\nfunction enableRTL() {\n  if (maplibregl__default.getRTLTextPluginStatus() === \"unavailable\") {\n    maplibregl__default.setRTLTextPlugin(defaults.rtlPluginURL, null, true\n    // Lazy load the plugin\n    );\n  }\n}\n\nfunction bindAll(fns, context) {\n  fns.forEach(fn => {\n    if (!context[fn]) {\n      return;\n    }\n    context[fn] = context[fn].bind(context);\n  });\n}\nfunction DOMcreate(tagName, className, container) {\n  const el = window.document.createElement(tagName);\n  if (className !== void 0) el.className = className;\n  if (container) container.appendChild(el);\n  return el;\n}\nfunction DOMremove(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction maptilerCloudTransformRequest(url, resourceType) {\n  let reqUrl = null;\n  try {\n    reqUrl = new URL(url);\n  } catch (e) {\n    return {\n      url\n    };\n  }\n  if (reqUrl.host === defaults.maptilerApiHost) {\n    if (!reqUrl.searchParams.has(\"key\")) {\n      reqUrl.searchParams.append(\"key\", config.apiKey);\n    }\n    if (config.session) {\n      reqUrl.searchParams.append(\"mtsid\", MAPTILER_SESSION_ID);\n    }\n  }\n  return {\n    url: reqUrl.href\n  };\n}\nfunction combineTransformRequest(userDefinedRTF = null) {\n  return function (url, resourceType) {\n    if (userDefinedRTF) {\n      const rp = userDefinedRTF(url, resourceType);\n      const rp2 = maptilerCloudTransformRequest(rp.url);\n      return __spreadValues$2(__spreadValues$2({}, rp), rp2);\n    } else {\n      return maptilerCloudTransformRequest(url);\n    }\n  };\n}\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    if (!style.startsWith(\"http\") && style.toLowerCase().includes(\".json\")) {\n      return style;\n    } else {\n      return expandMapStyle(style);\n    }\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getExpandedStyleURL();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getExpandedStyleURL();\n  }\n  return style;\n}\nclass MaptilerTerrainControl {\n  constructor() {\n    bindAll([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n  onAdd(map) {\n    this._map = map;\n    this._container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    this._terrainButton = DOMcreate(\"button\", \"maplibregl-ctrl-terrain\", this._container);\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\"aria-hidden\", \"true\");\n    this._terrainButton.type = \"button\";\n    this._terrainButton.addEventListener(\"click\", this._toggleTerrain);\n    this._updateTerrainIcon();\n    this._map.on(\"terrain\", this._updateTerrainIcon);\n    return this._container;\n  }\n  onRemove() {\n    DOMremove(this._container);\n    this._map.off(\"terrain\", this._updateTerrainIcon);\n    this._map = void 0;\n  }\n  _toggleTerrain() {\n    if (this._map.hasTerrain()) {\n      this._map.disableTerrain();\n    } else {\n      this._map.enableTerrain();\n    }\n    this._updateTerrainIcon();\n  }\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\");\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\");\n    if (this._map.hasTerrain()) {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\");\n      this._terrainButton.title = this._map._getUIString(\"TerrainControl.disableTerrain\");\n    } else {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\");\n      this._terrainButton.title = this._map._getUIString(\"TerrainControl.enableTerrain\");\n    }\n  }\n}\nclass NavigationControl extends maplibregl__default.NavigationControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nclass MaptilerNavigationControl extends NavigationControl {\n  constructor() {\n    super({\n      showCompass: true,\n      showZoom: true,\n      visualizePitch: true\n    });\n    this._compass.removeEventListener(\"click\", this._compass.clickFunction);\n    this._compass.addEventListener(\"click\", e => {\n      {\n        const currentPitch = this._map.getPitch();\n        if (currentPitch === 0) {\n          this._map.easeTo({\n            pitch: Math.min(this._map.getMaxPitch(), 80)\n          });\n        } else {\n          if (this.options.visualizePitch) {\n            this._map.resetNorthPitch({}, {\n              originalEvent: e\n            });\n          } else {\n            this._map.resetNorth({}, {\n              originalEvent: e\n            });\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(className, fn) {\n    const button = super._createButton(className, fn);\n    button.clickFunction = fn;\n    return button;\n  }\n  /**\n   * Overloading: Limit how flat the compass icon can get\n   */\n  _rotateCompassArrow() {\n    const rotate = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5))}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n    this._compassIcon.style.transform = rotate;\n  }\n}\nclass GeolocateControl extends maplibregl__default.GeolocateControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {\n    if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst Marker$1 = maplibregl__default.Marker;\nconst LngLat$1 = maplibregl__default.LngLat;\nconst LngLatBounds$1 = maplibregl__default.LngLatBounds;\nclass MaptilerGeolocateControl extends GeolocateControl {\n  constructor() {\n    super(...arguments);\n    this.lastUpdatedCenter = new LngLat$1(0, 0);\n  }\n  /**\n   * Update the camera location to center on the current position\n   *\n   * @param {Position} position the Geolocation API Position\n   * @private\n   */\n  _updateCamera(position) {\n    const center = new LngLat$1(position.coords.longitude, position.coords.latitude);\n    const radius = position.coords.accuracy;\n    const bearing = this._map.getBearing();\n    const options = __spreadProps$1(__spreadValues$1({\n      bearing\n    }, this.options.fitBoundsOptions), {\n      linear: true\n    });\n    const currentMapZoom = this._map.getZoom();\n    if (currentMapZoom > this.options.fitBoundsOptions.maxZoom) {\n      options.zoom = currentMapZoom;\n    }\n    this._map.fitBounds(LngLatBounds$1.fromLngLat(center, radius), options, {\n      geolocateSource: true\n      // tag this camera change so it won't cause the control to change to background state\n    });\n\n    let hasFittingBeenDisrupted = false;\n    const flagFittingDisruption = () => {\n      hasFittingBeenDisrupted = true;\n    };\n    this._map.once(\"click\", flagFittingDisruption);\n    this._map.once(\"dblclick\", flagFittingDisruption);\n    this._map.once(\"dragstart\", flagFittingDisruption);\n    this._map.once(\"mousedown\", flagFittingDisruption);\n    this._map.once(\"touchstart\", flagFittingDisruption);\n    this._map.once(\"wheel\", flagFittingDisruption);\n    this._map.once(\"moveend\", () => {\n      this._map.off(\"click\", flagFittingDisruption);\n      this._map.off(\"dblclick\", flagFittingDisruption);\n      this._map.off(\"dragstart\", flagFittingDisruption);\n      this._map.off(\"mousedown\", flagFittingDisruption);\n      this._map.off(\"touchstart\", flagFittingDisruption);\n      this._map.off(\"wheel\", flagFittingDisruption);\n      if (hasFittingBeenDisrupted) {\n        return;\n      }\n      this.lastUpdatedCenter = this._map.getCenter();\n    });\n  }\n  _setupUI(supported) {\n    this.lastUpdatedCenter = this._map.getCenter();\n    this._container.addEventListener(\"contextmenu\", e => e.preventDefault());\n    this._geolocateButton = DOMcreate(\"button\", \"maplibregl-ctrl-geolocate\", this._container);\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\");\n    this._geolocateButton.type = \"button\";\n    if (supported === false) {\n      const title = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n      this._geolocateButton.disabled = true;\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    } else {\n      const title = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    }\n    if (this.options.trackUserLocation) {\n      this._geolocateButton.setAttribute(\"aria-pressed\", \"false\");\n      this._watchState = \"OFF\";\n    }\n    if (this.options.showUserLocation) {\n      this._dotElement = DOMcreate(\"div\", \"maplibregl-user-location-dot\");\n      this._userLocationDotMarker = new Marker$1(this._dotElement);\n      this._circleElement = DOMcreate(\"div\", \"maplibregl-user-location-accuracy-circle\");\n      this._accuracyCircleMarker = new Marker$1({\n        element: this._circleElement,\n        pitchAlignment: \"map\"\n      });\n      if (this.options.trackUserLocation) this._watchState = \"OFF\";\n      this._map.on(\"move\", this._onZoom);\n    }\n    this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this));\n    this._setup = true;\n    if (this.options.trackUserLocation) {\n      this._map.on(\"moveend\", event => {\n        const fromResize = event.originalEvent && event.originalEvent.type === \"resize\";\n        const movingDistance = this.lastUpdatedCenter.distanceTo(this._map.getCenter());\n        if (!event.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !fromResize && movingDistance > 1) {\n          this._watchState = \"BACKGROUND\";\n          this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\");\n          this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\");\n          this.fire(new Event(\"trackuserlocationend\"));\n        }\n      });\n    }\n  }\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\") {\n      return;\n    }\n    const lastKnownLocation = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude];\n    const projectedLocation = this._map.project(lastKnownLocation);\n    const a = this._map.unproject([projectedLocation.x, projectedLocation.y]);\n    const b = this._map.unproject([projectedLocation.x + 20, projectedLocation.y]);\n    const metersPerPixel = a.distanceTo(b) / 20;\n    const circleDiameter = Math.ceil(2 * this._accuracy / metersPerPixel);\n    this._circleElement.style.width = `${circleDiameter}px`;\n    this._circleElement.style.height = `${circleDiameter}px`;\n  }\n  _onZoom() {\n    if (this.options.showUserLocation && this.options.showAccuracyCircle) {\n      this._updateCircleRadius();\n    }\n  }\n}\nclass AttributionControl extends maplibregl__default.AttributionControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nclass ScaleControl extends maplibregl__default.ScaleControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nclass FullscreenControl extends maplibregl__default.FullscreenControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst GeolocationType = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\"\n};\nclass Map extends maplibregl__default.Map {\n  constructor(options) {\n    var _a, _b, _c;\n    if (options.apiKey) {\n      config.apiKey = options.apiKey;\n    }\n    const style = styleToStyle(options.style);\n    const hashPreConstructor = location.hash;\n    if (!config.apiKey) {\n      console.warn(\"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\");\n    }\n    super(__spreadProps(__spreadValues({}, options), {\n      style,\n      maplibreLogo: false,\n      transformRequest: combineTransformRequest(options.transformRequest)\n    }));\n    this.isTerrainEnabled = false;\n    this.terrainExaggeration = 1;\n    this.primaryLanguage = null;\n    this.secondaryLanguage = null;\n    this.terrainGrowing = false;\n    this.terrainFlattening = false;\n    this.primaryLanguage = (_a = options.language) != null ? _a : config.primaryLanguage;\n    this.secondaryLanguage = config.secondaryLanguage;\n    this.terrainExaggeration = (_b = options.terrainExaggeration) != null ? _b : this.terrainExaggeration;\n    this.once(\"styledata\", () => __async(this, null, function* () {\n      if (!options.geolocate) {\n        return;\n      }\n      if (options.center) {\n        return;\n      }\n      if (options.hash && !!hashPreConstructor) {\n        return;\n      }\n      try {\n        if (options.geolocate === GeolocationType.COUNTRY) {\n          yield this.fitToIpBounds();\n          return;\n        }\n      } catch (e) {\n        console.warn(e.message);\n      }\n      let ipLocatedCameraHash = null;\n      try {\n        yield this.centerOnIpPoint(options.zoom);\n        ipLocatedCameraHash = this.getCameraHash();\n      } catch (e) {\n        console.warn(e.message);\n      }\n      const locationResult = yield navigator.permissions.query({\n        name: \"geolocation\"\n      });\n      if (locationResult.state === \"granted\") {\n        navigator.geolocation.getCurrentPosition(\n        // success callback\n        data => {\n          if (ipLocatedCameraHash !== this.getCameraHash()) {\n            return;\n          }\n          if (this.terrain) {\n            this.easeTo({\n              center: [data.coords.longitude, data.coords.latitude],\n              zoom: options.zoom || 12,\n              duration: 2e3\n            });\n          } else {\n            this.once(\"terrain\", () => {\n              this.easeTo({\n                center: [data.coords.longitude, data.coords.latitude],\n                zoom: options.zoom || 12,\n                duration: 2e3\n              });\n            });\n          }\n        },\n        // error callback\n        null,\n        // options\n        {\n          maximumAge: 24 * 3600 * 1e3,\n          // a day in millisec\n          timeout: 5e3,\n          // milliseconds\n          enableHighAccuracy: false\n        });\n      }\n    }));\n    this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n      this.setSecondaryLanguage(this.secondaryLanguage);\n    });\n    this.on(\"styledata\", () => {\n      if (this.getTerrain() === null && this.isTerrainEnabled) {\n        this.enableTerrain(this.terrainExaggeration);\n      }\n    });\n    this.once(\"load\", () => __async(this, null, function* () {\n      enableRTL();\n    }));\n    this.once(\"load\", () => __async(this, null, function* () {\n      let tileJsonContent = {\n        logo: null\n      };\n      try {\n        const possibleSources = Object.keys(this.style.sourceCaches).map(sourceName => this.getSource(sourceName)).filter(s => typeof s.url === \"string\" && s.url.includes(\"tiles.json\"));\n        const styleUrl = new URL(possibleSources[0].url);\n        if (!styleUrl.searchParams.has(\"key\")) {\n          styleUrl.searchParams.append(\"key\", config.apiKey);\n        }\n        const tileJsonRes = yield fetch(styleUrl.href);\n        tileJsonContent = yield tileJsonRes.json();\n      } catch (e) {}\n      if (\"logo\" in tileJsonContent && tileJsonContent.logo) {\n        const logoURL = tileJsonContent.logo;\n        this.addControl(new MaptilerLogoControl({\n          logoURL\n        }), options.logoPosition);\n        if (options.attributionControl === false) {\n          this.addControl(new AttributionControl({\n            customAttribution: options.customAttribution\n          }));\n        }\n      } else if (options.maptilerLogo) {\n        this.addControl(new MaptilerLogoControl(), options.logoPosition);\n      }\n      if (options.scaleControl) {\n        const position = options.scaleControl === true || options.scaleControl === void 0 ? \"bottom-right\" : options.scaleControl;\n        const scaleControl = new ScaleControl({\n          unit: config.unit\n        });\n        this.addControl(scaleControl, position);\n        config.on(\"unit\", unit => {\n          scaleControl.setUnit(unit);\n        });\n      }\n      if (options.navigationControl !== false) {\n        const position = options.navigationControl === true || options.navigationControl === void 0 ? \"top-right\" : options.navigationControl;\n        this.addControl(new MaptilerNavigationControl(), position);\n      }\n      if (options.geolocateControl !== false) {\n        const position = options.geolocateControl === true || options.geolocateControl === void 0 ? \"top-right\" : options.geolocateControl;\n        this.addControl(\n        // new maplibregl.GeolocateControl({\n        new MaptilerGeolocateControl({\n          positionOptions: {\n            enableHighAccuracy: true,\n            maximumAge: 0,\n            timeout: 6e3\n          },\n          fitBoundsOptions: {\n            maxZoom: 15\n          },\n          trackUserLocation: true,\n          showAccuracyCircle: true,\n          showUserLocation: true\n        }), position);\n      }\n      if (options.terrainControl) {\n        const position = options.terrainControl === true || options.terrainControl === void 0 ? \"top-right\" : options.terrainControl;\n        this.addControl(new MaptilerTerrainControl(), position);\n      }\n      if (options.fullscreenControl) {\n        const position = options.fullscreenControl === true || options.fullscreenControl === void 0 ? \"top-right\" : options.fullscreenControl;\n        this.addControl(new FullscreenControl({}), position);\n      }\n    }));\n    let loadEventTriggered = false;\n    let terrainEventTriggered = false;\n    let terrainEventData = null;\n    this.once(\"load\", _ => {\n      loadEventTriggered = true;\n      if (terrainEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    });\n    const terrainCallback = evt => {\n      if (!evt.terrain) return;\n      terrainEventTriggered = true;\n      terrainEventData = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: evt.terrain\n      };\n      this.off(\"terrain\", terrainCallback);\n      if (loadEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    };\n    this.on(\"terrain\", terrainCallback);\n    if (options.terrain) {\n      this.enableTerrain((_c = options.terrainExaggeration) != null ? _c : this.terrainExaggeration);\n    }\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  onLoadAsync() {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        if (this.loaded()) {\n          return resolve(this);\n        }\n        this.once(\"load\", _ => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  onLoadWithTerrainAsync() {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        if (this.loaded() && this.terrain) {\n          return resolve(this);\n        }\n        this.once(\"loadWithTerrain\", _ => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   * @param style\n   * @param options\n   * @returns\n   */\n  setStyle(style, options) {\n    return super.setStyle(styleToStyle(style), options);\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   * This function is a short for `.setPrimaryLanguage()`\n   * @param language\n   */\n  setLanguage(language = defaults.primaryLanguage) {\n    if (language === Language.AUTO) {\n      return this.setLanguage(getBrowserLanguage());\n    }\n    this.setPrimaryLanguage(language);\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   * @param language\n   */\n  setPrimaryLanguage(language = defaults.primaryLanguage) {\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\");\n      return;\n    }\n    if (!isLanguageSupported(language)) {\n      return;\n    }\n    this.primaryLanguage = language;\n    this.onStyleReady(() => {\n      if (language === Language.AUTO) {\n        return this.setPrimaryLanguage(getBrowserLanguage());\n      }\n      const layers = this.getStyle().layers;\n      const strLanguageRegex = /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n      const strLanguageInArrayRegex = /^\\s*name\\s*(:\\s*(\\S*))?\\s*$/;\n      const strBilingualRegex = /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}(\\s*){\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n      const strMoreInfoRegex = /^(.*)({\\s*name\\s*(:\\s*(\\S*))?\\s*})(.*)$/;\n      const langStr = language ? `name:${language}` : \"name\";\n      const replacer = [\"case\", [\"has\", langStr], [\"get\", langStr], [\"get\", \"name\"]];\n      for (let i = 0; i < layers.length; i += 1) {\n        const layer = layers[i];\n        const layout = layer.layout;\n        if (!layout) {\n          continue;\n        }\n        if (!layout[\"text-field\"]) {\n          continue;\n        }\n        const textFieldLayoutProp = this.getLayoutProperty(layer.id, \"text-field\");\n        let regexMatch;\n        if (Array.isArray(textFieldLayoutProp) && textFieldLayoutProp.length >= 2 && textFieldLayoutProp[0].trim().toLowerCase() === \"concat\") {\n          const newProp = textFieldLayoutProp.slice();\n          for (let j = 0; j < textFieldLayoutProp.length; j += 1) {\n            const elem = textFieldLayoutProp[j];\n            if ((typeof elem === \"string\" || elem instanceof String) && strLanguageRegex.exec(elem.toString())) {\n              newProp[j] = replacer;\n              break;\n            } else if (Array.isArray(elem) && elem.length >= 2 && elem[0].trim().toLowerCase() === \"get\" && strLanguageInArrayRegex.exec(elem[1].toString())) {\n              newProp[j] = replacer;\n              break;\n            } else if (Array.isArray(elem) && elem.length === 4 && elem[0].trim().toLowerCase() === \"case\") {\n              newProp[j] = replacer;\n              break;\n            }\n          }\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if (Array.isArray(textFieldLayoutProp) && textFieldLayoutProp.length >= 2 && textFieldLayoutProp[0].trim().toLowerCase() === \"get\" && strLanguageInArrayRegex.exec(textFieldLayoutProp[1].toString())) {\n          const newProp = replacer;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if ((typeof textFieldLayoutProp === \"string\" || textFieldLayoutProp instanceof String) && strLanguageRegex.exec(textFieldLayoutProp.toString())) {\n          const newProp = replacer;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if (Array.isArray(textFieldLayoutProp) && textFieldLayoutProp.length === 4 && textFieldLayoutProp[0].trim().toLowerCase() === \"case\") {\n          const newProp = replacer;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if ((typeof textFieldLayoutProp === \"string\" || textFieldLayoutProp instanceof String) && (regexMatch = strBilingualRegex.exec(textFieldLayoutProp.toString())) !== null) {\n          const newProp = `{${langStr}}${regexMatch[3]}{name${regexMatch[4] || \"\"}}`;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if ((typeof textFieldLayoutProp === \"string\" || textFieldLayoutProp instanceof String) && (regexMatch = strMoreInfoRegex.exec(textFieldLayoutProp.toString())) !== null) {\n          const newProp = `${regexMatch[1]}{${langStr}}${regexMatch[5]}`;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        }\n      }\n    });\n  }\n  /**\n   * Define the secondary language of the map. Note that this is not supported by all the map styles\n   * Note that most styles do not allow a secondary language and this function only works if the style allows (no force adding)\n   * @param language\n   */\n  setSecondaryLanguage(language = defaults.secondaryLanguage) {\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\");\n      return;\n    }\n    if (!isLanguageSupported(language)) {\n      return;\n    }\n    this.secondaryLanguage = language;\n    this.onStyleReady(() => {\n      if (language === Language.AUTO) {\n        return this.setSecondaryLanguage(getBrowserLanguage());\n      }\n      const layers = this.getStyle().layers;\n      const strLanguageRegex = /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n      const strLanguageInArrayRegex = /^\\s*name\\s*(:\\s*(\\S*))?\\s*$/;\n      const strBilingualRegex = /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}(\\s*){\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n      let regexMatch;\n      for (let i = 0; i < layers.length; i += 1) {\n        const layer = layers[i];\n        const layout = layer.layout;\n        if (!layout) {\n          continue;\n        }\n        if (!layout[\"text-field\"]) {\n          continue;\n        }\n        const textFieldLayoutProp = this.getLayoutProperty(layer.id, \"text-field\");\n        let newProp;\n        if (Array.isArray(textFieldLayoutProp) && textFieldLayoutProp.length >= 2 && textFieldLayoutProp[0].trim().toLowerCase() === \"concat\") {\n          newProp = textFieldLayoutProp.slice();\n          let languagesAlreadyFound = 0;\n          for (let j = 0; j < textFieldLayoutProp.length; j += 1) {\n            const elem = textFieldLayoutProp[j];\n            if ((typeof elem === \"string\" || elem instanceof String) && strLanguageRegex.exec(elem.toString())) {\n              if (languagesAlreadyFound === 1) {\n                newProp[j] = `{name:${language}}`;\n                break;\n              }\n              languagesAlreadyFound += 1;\n            } else if (Array.isArray(elem) && elem.length >= 2 && elem[0].trim().toLowerCase() === \"get\" && strLanguageInArrayRegex.exec(elem[1].toString())) {\n              if (languagesAlreadyFound === 1) {\n                newProp[j][1] = `name:${language}`;\n                break;\n              }\n              languagesAlreadyFound += 1;\n            } else if (Array.isArray(elem) && elem.length === 4 && elem[0].trim().toLowerCase() === \"case\") {\n              if (languagesAlreadyFound === 1) {\n                newProp[j] = [\"get\", `name:${language}`];\n                break;\n              }\n              languagesAlreadyFound += 1;\n            }\n          }\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if ((typeof textFieldLayoutProp === \"string\" || textFieldLayoutProp instanceof String) && (regexMatch = strBilingualRegex.exec(textFieldLayoutProp.toString())) !== null) {\n          const langStr = language ? `name:${language}` : \"name\";\n          newProp = `{name${regexMatch[1] || \"\"}}${regexMatch[3]}{${langStr}}`;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        }\n      }\n    });\n  }\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage() {\n    return this.primaryLanguage;\n  }\n  /**\n   * Get the secondary language\n   * @returns\n   */\n  getSecondaryLanguage() {\n    return this.secondaryLanguage;\n  }\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration() {\n    return this.terrainExaggeration;\n  }\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain() {\n    return this.isTerrainEnabled;\n  }\n  growTerrain(exaggeration, durationMs = 1e3) {\n    if (!this.terrain) {\n      return;\n    }\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const deltaExaggeration = exaggeration - currentExaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainFlattening) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / durationMs;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = 1 - Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration + exaggerationFactor * deltaExaggeration;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.terrain.exaggeration = exaggeration;\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = true;\n    this.terrainFlattening = false;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Enables the 3D terrain visualization\n   * @param exaggeration\n   * @returns\n   */\n  enableTerrain(exaggeration = this.terrainExaggeration) {\n    if (exaggeration < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n    const dataEventTerrainGrow = evt => __async(this, null, function* () {\n      if (!this.terrain) {\n        return;\n      }\n      if (evt.type !== \"data\" || evt.dataType !== \"source\" || !(\"source\" in evt)) {\n        return;\n      }\n      if (evt.sourceId !== \"maptiler-terrain\") {\n        return;\n      }\n      const source = evt.source;\n      if (source.type !== \"raster-dem\") {\n        return;\n      }\n      if (!evt.isSourceLoaded) {\n        return;\n      }\n      this.off(\"data\", dataEventTerrainGrow);\n      this.growTerrain(exaggeration);\n    });\n    const addTerrain = () => {\n      this.isTerrainEnabled = true;\n      this.terrainExaggeration = exaggeration;\n      this.on(\"data\", dataEventTerrainGrow);\n      this.addSource(defaults.terrainSourceId, {\n        type: \"raster-dem\",\n        url: defaults.terrainSourceURL\n      });\n      this.setTerrain({\n        source: defaults.terrainSourceId,\n        exaggeration: 0\n      });\n    };\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = true;\n      this.growTerrain(exaggeration);\n      return;\n    }\n    if (this.loaded() || this.isTerrainEnabled) {\n      addTerrain();\n    } else {\n      this.once(\"load\", () => {\n        if (this.getTerrain() && this.getSource(defaults.terrainSourceId)) {\n          return;\n        }\n        addTerrain();\n      });\n    }\n  }\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    if (!this.terrain) {\n      return;\n    }\n    this.isTerrainEnabled = false;\n    const animationLoopDuration = 1 * 1e3;\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainGrowing) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / animationLoopDuration;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration * exaggerationFactor;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrain.exaggeration = 0;\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.setTerrain(null);\n        if (this.getSource(defaults.terrainSourceId)) {\n          this.removeSource(defaults.terrainSourceId);\n        }\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = false;\n    this.terrainFlattening = true;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   * @param exaggeration\n   * @param animate\n   */\n  setTerrainExaggeration(exaggeration, animate = true) {\n    if (!animate && this.terrain) {\n      this.terrainExaggeration = exaggeration;\n      this.terrain.exaggeration = exaggeration;\n      this.triggerRepaint();\n    } else {\n      this.enableTerrain(exaggeration);\n    }\n  }\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   * @param cb\n   */\n  onStyleReady(cb) {\n    if (this.isStyleLoaded()) {\n      cb();\n    } else {\n      this.once(\"styledata\", () => {\n        cb();\n      });\n    }\n  }\n  fitToIpBounds() {\n    return __async(this, null, function* () {\n      const ipGeolocateResult = yield geolocation.info();\n      this.fitBounds(ipGeolocateResult.country_bounds, {\n        duration: 0,\n        padding: 100\n      });\n    });\n  }\n  centerOnIpPoint(zoom) {\n    return __async(this, null, function* () {\n      const ipGeolocateResult = yield geolocation.info();\n      this.jumpTo({\n        center: [ipGeolocateResult.longitude, ipGeolocateResult.latitude],\n        zoom: zoom || 11\n      });\n    });\n  }\n  getCameraHash() {\n    const hashBin = new Float32Array(5);\n    const center = this.getCenter();\n    hashBin[0] = center.lng;\n    hashBin[1] = center.lat;\n    hashBin[2] = this.getZoom();\n    hashBin[3] = this.getPitch();\n    hashBin[4] = this.getBearing();\n    return Base64.fromUint8Array(new Uint8Array(hashBin.buffer));\n  }\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getSdkConfig() {\n    return config;\n  }\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId() {\n    return MAPTILER_SESSION_ID;\n  }\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(transformRequest) {\n    super.setTransformRequest(combineTransformRequest(transformRequest));\n    return this;\n  }\n}\nclass Marker extends maplibregl__default.Marker {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\nclass Popup extends maplibregl__default.Popup {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\nclass Style extends maplibregl__default.Style {\n  constructor(map, options = {}) {\n    super(map, options);\n  }\n}\nclass CanvasSource extends maplibregl__default.CanvasSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass GeoJSONSource extends maplibregl__default.GeoJSONSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass ImageSource extends maplibregl__default.ImageSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass RasterTileSource extends maplibregl__default.RasterTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass RasterDEMTileSource extends maplibregl__default.RasterDEMTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass VectorTileSource extends maplibregl__default.VectorTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass VideoSource extends maplibregl__default.VideoSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass TerrainControl extends maplibregl__default.TerrainControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  _matMult(m) {\n    const x = m[0] * this.x + m[1] * this.y;\n    const y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _add(p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  _sub(p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  }\n  _mult(k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n  _div(k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  }\n  _multByPoint(p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  }\n  _divByPoint(p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  }\n  _unit() {\n    this._div(this.mag());\n    return this;\n  }\n  _perp() {\n    const y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  }\n  _rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * this.x - sin * this.y;\n    const y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _rotateAround(angle, p) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y);\n    const y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add(p) {\n    return this.clone()._add(p);\n  }\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub(p) {\n    return this.clone()._sub(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint(p) {\n    return this.clone()._multByPoint(p);\n  }\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint(p) {\n    return this.clone()._divByPoint(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Number} k factor\n   * @return {Point} output point\n   */\n  mult(k) {\n    return this.clone()._mult(k);\n  }\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div(k) {\n    return this.clone()._div(k);\n  }\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate(a) {\n    return this.clone()._rotate(a);\n  }\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround(a, p) {\n    return this.clone()._rotateAround(a, p);\n  }\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult(m) {\n    return this.clone()._matMult(m);\n  }\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit() {\n    return this.clone()._unit();\n  }\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp() {\n    return this.clone()._perp();\n  }\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round() {\n    return this.clone()._round();\n  }\n  /**\n   * Return the magnitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist(p) {\n    return Math.sqrt(this.distSqr(p));\n  }\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr(p) {\n    const dx = p.x - this.x;\n    const dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  }\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle() {\n    return Math.atan2(this.y, this.x);\n  }\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo(b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  }\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith(b) {\n    return this.angleWithSep(b.x, b.y);\n  }\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin(θ) for θ.\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep(x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  }\n  /**\n   * Construct a point from an array if necessary, otherwise if the input\n   * is already a Point, or an unknown type, return it unchanged\n   * @param {Array<number> | Point} a any kind of input value\n   * @return {Point} constructed point, or passed-through value.\n   * @example\n   * // this\n   * var point = Point.convert([0, 1]);\n   * // is equivalent to\n   * var point = new Point(0, 1);\n   */\n  static convert(a) {\n    if (a instanceof Point) {\n      return a;\n    }\n    if (Array.isArray(a)) {\n      return new Point(a[0], a[1]);\n    }\n    return a;\n  }\n}\nconst {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol\n} = maplibregl__default;\nconst MapMLGL = maplibregl__default.Map;\nconst MarkerMLGL = maplibregl__default.Marker;\nconst PopupMLGL = maplibregl__default.Popup;\nconst StyleMLGL = maplibregl__default.Style;\nconst CanvasSourceMLGL = maplibregl__default.CanvasSource;\nconst GeoJSONSourceMLGL = maplibregl__default.GeoJSONSource;\nconst ImageSourceMLGL = maplibregl__default.ImageSource;\nconst RasterTileSourceMLGL = maplibregl__default.RasterTileSource;\nconst RasterDEMTileSourceMLGL = maplibregl__default.RasterDEMTileSource;\nconst VectorTileSourceMLGL = maplibregl__default.VectorTileSource;\nconst VideoSourceMLGL = maplibregl__default.VideoSource;\nmaplibregl__default.NavigationControl;\nmaplibregl__default.GeolocateControl;\nmaplibregl__default.AttributionControl;\nmaplibregl__default.LogoControl;\nmaplibregl__default.ScaleControl;\nmaplibregl__default.FullscreenControl;\nmaplibregl__default.TerrainControl;\nexport { AJAXError, AttributionControl, CanvasSource, CanvasSourceMLGL, Evented, FullscreenControl, GeoJSONSource, GeoJSONSourceMLGL, GeolocateControl, GeolocationType, ImageSource, ImageSourceMLGL, Language, LngLat, LngLatBounds, LogoControl, Map, MapMLGL, MaptilerGeolocateControl, MaptilerLogoControl, MaptilerNavigationControl, MaptilerTerrainControl, Marker, MarkerMLGL, MercatorCoordinate, NavigationControl, Point, Popup, PopupMLGL, RasterDEMTileSource, RasterDEMTileSourceMLGL, RasterTileSource, RasterTileSourceMLGL, ScaleControl, SdkConfig, Style, StyleMLGL, TerrainControl, VectorTileSource, VectorTileSourceMLGL, VideoSource, VideoSourceMLGL, addProtocol, clearPrewarmedResources, config, getRTLTextPluginStatus, maxParallelImageRequests, prewarm, removeProtocol, setRTLTextPlugin, version, workerCount, workerUrl };","map":{"version":3,"names":["Language","AUTO","STYLE_LOCK","LATIN","NON_LATIN","LOCAL","ALBANIAN","AMHARIC","ARABIC","ARMENIAN","AZERBAIJANI","BASQUE","BELORUSSIAN","BOSNIAN","BRETON","BULGARIAN","CATALAN","CHINESE","CORSICAN","CROATIAN","CZECH","DANISH","DUTCH","ENGLISH","ESPERANTO","ESTONIAN","FINNISH","FRENCH","FRISIAN","GEORGIAN","GERMAN","GREEK","HEBREW","HINDI","HUNGARIAN","ICELANDIC","INDONESIAN","IRISH","ITALIAN","JAPANESE","JAPANESE_HIRAGANA","JAPANESE_KANA","JAPANESE_LATIN","JAPANESE_2018","KANNADA","KAZAKH","KOREAN","KOREAN_LATIN","KURDISH","ROMAN_LATIN","LATVIAN","LITHUANIAN","LUXEMBOURGISH","MACEDONIAN","MALAYALAM","MALTESE","NORWEGIAN","OCCITAN","POLISH","PORTUGUESE","ROMANIAN","ROMANSH","RUSSIAN","SCOTTISH_GAELIC","SERBIAN_CYRILLIC","SERBIAN_LATIN","SLOVAK","SLOVENE","SPANISH","SWEDISH","TAMIL","TELUGU","THAI","TURKISH","UKRAINIAN","WELSH","languagesIsoSet","Set","Object","values","isLanguageSupported","lang","has","languageCodeSet","getBrowserLanguage","navigator","Intl","DateTimeFormat","resolvedOptions","locale","split","canditatelangs","Array","from","languages","map","l","filter","length","MAPTILER_SESSION_ID","v4","SdkConfig","EventEmitter","constructor","primaryLanguage","secondaryLanguage","session","_unit","_apiKey","unit","u","emit","apiKey","k","config$1","fetch","f","config","defaults","maptilerLogoURL","maptilerURL","maptilerApiHost","rtlPluginURL","terrainSourceURL","terrainSourceId","freeze","LogoControl","maplibregl__default","onAdd","MaptilerLogoControl","options","_a","_b","logoURL","linkURL","_map","_compact","compact","_container","window","document","createElement","className","anchor","style","backgroundRepeat","cursor","display","height","margin","overflow","width","backgroundImage","backgroundSize","target","rel","href","setAttribute","appendChild","on","_updateCompact","enableRTL","getRTLTextPluginStatus","setRTLTextPlugin","bindAll","fns","context","forEach","fn","bind","DOMcreate","tagName","container","el","DOMremove","node","parentNode","removeChild","maptilerCloudTransformRequest","url","resourceType","reqUrl","URL","e","host","searchParams","append","combineTransformRequest","userDefinedRTF","rp","rp2","__spreadValues$2","styleToStyle","MapStyle","mapStylePresetList","referenceStyleID","getDefaultVariant","getExpandedStyleURL","String","startsWith","toLowerCase","includes","expandMapStyle","MapStyleVariant","ReferenceMapStyle","MaptilerTerrainControl","_terrainButton","type","addEventListener","_toggleTerrain","_updateTerrainIcon","onRemove","off","hasTerrain","disableTerrain","enableTerrain","classList","remove","add","title","_getUIString","NavigationControl","MaptilerNavigationControl","showCompass","showZoom","visualizePitch","_compass","removeEventListener","clickFunction","currentPitch","getPitch","easeTo","pitch","Math","min","getMaxPitch","resetNorthPitch","originalEvent","resetNorth","_createButton","button","_rotateCompassArrow","rotate","pow","cos","transform","PI","angle","_compassIcon","GeolocateControl","Marker$1","Marker","LngLat$1","LngLat","LngLatBounds$1","LngLatBounds","MaptilerGeolocateControl","arguments","lastUpdatedCenter","_updateCamera","position","center","coords","longitude","latitude","radius","accuracy","bearing","getBearing","__spreadProps$1","__spreadValues$1","fitBoundsOptions","linear","currentMapZoom","getZoom","maxZoom","zoom","fitBounds","fromLngLat","geolocateSource","hasFittingBeenDisrupted","flagFittingDisruption","once","getCenter","_setupUI","supported","preventDefault","_geolocateButton","disabled","trackUserLocation","_watchState","showUserLocation","_dotElement","_userLocationDotMarker","_circleElement","_accuracyCircleMarker","element","pitchAlignment","_onZoom","trigger","_setup","event","fromResize","movingDistance","distanceTo","fire","Event","_updateCircleRadius","lastKnownLocation","_lastKnownPosition","projectedLocation","project","a","unproject","x","y","b","metersPerPixel","circleDiameter","ceil","_accuracy","showAccuracyCircle","AttributionControl","ScaleControl","FullscreenControl","GeolocationType","POINT","COUNTRY","Map","_c","hashPreConstructor","location","hash","console","warn","__spreadProps","__spreadValues","maplibreLogo","transformRequest","isTerrainEnabled","terrainExaggeration","terrainGrowing","terrainFlattening","language","__async","geolocate","fitToIpBounds","message","ipLocatedCameraHash","centerOnIpPoint","getCameraHash","locationResult","permissions","query","name","state","geolocation","getCurrentPosition","data","terrain","duration","maximumAge","timeout","enableHighAccuracy","setPrimaryLanguage","setSecondaryLanguage","getTerrain","tileJsonContent","logo","possibleSources","keys","sourceCaches","sourceName","getSource","s","styleUrl","tileJsonRes","json","addControl","logoPosition","attributionControl","customAttribution","maptilerLogo","scaleControl","setUnit","navigationControl","geolocateControl","positionOptions","terrainControl","fullscreenControl","loadEventTriggered","terrainEventTriggered","terrainEventData","_","terrainCallback","evt","onLoadAsync","Promise","resolve","reject","loaded","onLoadWithTerrainAsync","setStyle","setLanguage","onStyleReady","layers","getStyle","strLanguageRegex","strLanguageInArrayRegex","strBilingualRegex","strMoreInfoRegex","langStr","replacer","i","layer","layout","textFieldLayoutProp","getLayoutProperty","id","regexMatch","isArray","trim","newProp","slice","j","elem","exec","toString","setLayoutProperty","languagesAlreadyFound","getPrimaryLanguage","getSecondaryLanguage","getTerrainExaggeration","growTerrain","exaggeration","durationMs","startTime","performance","now","currentExaggeration","deltaExaggeration","updateExaggeration","positionInLoop","exaggerationFactor","newExaggeration","requestAnimationFrame","triggerRepaint","dataEventTerrainGrow","dataType","sourceId","source","isSourceLoaded","addTerrain","addSource","setTerrain","animationLoopDuration","removeSource","setTerrainExaggeration","animate","cb","isStyleLoaded","ipGeolocateResult","info","country_bounds","padding","jumpTo","hashBin","Float32Array","lng","lat","Base64","fromUint8Array","Uint8Array","buffer","getSdkConfig","getMaptilerSessionId","setTransformRequest","addTo","Popup","Style","CanvasSource","GeoJSONSource","ImageSource","RasterTileSource","RasterDEMTileSource","VectorTileSource","VideoSource","TerrainControl","Point","_matMult","m","_add","p","_sub","_mult","_div","_multByPoint","_divByPoint","mag","_perp","_rotate","sin","_rotateAround","_round","round","clone","sub","multByPoint","divByPoint","mult","div","rotateAround","matMult","perp","sqrt","equals","other","dist","distSqr","dx","dy","atan2","angleTo","angleWith","angleWithSep","convert","MercatorCoordinate","Evented","AJAXError","prewarm","clearPrewarmedResources","version","workerCount","maxParallelImageRequests","workerUrl","addProtocol","removeProtocol","MapMLGL","MarkerMLGL","PopupMLGL","StyleMLGL","CanvasSourceMLGL","GeoJSONSourceMLGL","ImageSourceMLGL","RasterTileSourceMLGL","RasterDEMTileSourceMLGL","VectorTileSourceMLGL","VideoSourceMLGL"],"sources":["C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\language.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\config.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\defaults.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\LogoControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\MaptilerLogoControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\tools.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\mapstyle.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\MaptilerTerrainControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\NavigationControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\MaptilerNavigationControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\GeolocateControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\MaptilerGeolocateControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\AttributionControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\ScaleControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\FullscreenControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\Map.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\Marker.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\Popup.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\Style.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\CanvasSource.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\GeoJSONSource.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\ImageSource.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\RasterTileSource.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\RasterDEMTileSource.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\VectorTileSource.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\VideoSource.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\TerrainControl.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\Point.ts","C:\\Users\\adrean paul sorono\\Desktop\\Errand Catcher\\ErrandCatcher\\client\\node_modules\\@maptiler\\sdk\\src\\index.ts"],"sourcesContent":["/**\n * Languages. Note that not all the languages of this list are available but the compatibility list may be expanded in the future.\n */\nconst Language = {\n  /**\n   * AUTO mode uses the language of the browser\n   */\n  AUTO: \"auto\",\n\n  /**\n   * STYLE is a custom flag to keep the language of the map as defined into the style.\n   * If STYLE is set in the constructor, then further modification of the language\n   * with `.setLanguage()` is not possible.\n   */\n  STYLE_LOCK: \"style_lock\",\n\n  /**\n   * Default fallback languages that uses latin charaters\n   */\n  LATIN: \"latin\",\n\n  /**\n   * Default fallback languages that uses non-latin charaters\n   */\n  NON_LATIN: \"nonlatin\",\n\n  /**\n   * Labels are in their local language, when available\n   */\n  LOCAL: \"\",\n\n  ALBANIAN: \"sq\",\n  AMHARIC: \"am\",\n  ARABIC: \"ar\",\n  ARMENIAN: \"hy\",\n  AZERBAIJANI: \"az\",\n  BASQUE: \"eu\",\n  BELORUSSIAN: \"be\",\n  BOSNIAN: \"bs\",\n  BRETON: \"br\",\n  BULGARIAN: \"bg\",\n  CATALAN: \"ca\",\n  CHINESE: \"zh\",\n  CORSICAN: \"co\",\n  CROATIAN: \"hr\",\n  CZECH: \"cs\",\n  DANISH: \"da\",\n  DUTCH: \"nl\",\n  ENGLISH: \"en\",\n  ESPERANTO: \"eo\",\n  ESTONIAN: \"et\",\n  FINNISH: \"fi\",\n  FRENCH: \"fr\",\n  FRISIAN: \"fy\",\n  GEORGIAN: \"ka\",\n  GERMAN: \"de\",\n  GREEK: \"el\",\n  HEBREW: \"he\",\n  HINDI: \"hi\",\n  HUNGARIAN: \"hu\",\n  ICELANDIC: \"is\",\n  INDONESIAN: \"id\",\n  IRISH: \"ga\",\n  ITALIAN: \"it\",\n  JAPANESE: \"ja\",\n  JAPANESE_HIRAGANA: \"ja-Hira\",\n  JAPANESE_KANA: \"ja_kana\",\n  JAPANESE_LATIN: \"ja_rm\",\n  JAPANESE_2018: \"ja-Latn\",\n  KANNADA: \"kn\",\n  KAZAKH: \"kk\",\n  KOREAN: \"ko\",\n  KOREAN_LATIN: \"ko-Latn\",\n  KURDISH: \"ku\",\n  ROMAN_LATIN: \"la\",\n  LATVIAN: \"lv\",\n  LITHUANIAN: \"lt\",\n  LUXEMBOURGISH: \"lb\",\n  MACEDONIAN: \"mk\",\n  MALAYALAM: \"ml\",\n  MALTESE: \"mt\",\n  NORWEGIAN: \"no\",\n  OCCITAN: \"oc\",\n  POLISH: \"pl\",\n  PORTUGUESE: \"pt\",\n  ROMANIAN: \"ro\",\n  ROMANSH: \"rm\",\n  RUSSIAN: \"ru\",\n  SCOTTISH_GAELIC: \"gd\",\n  SERBIAN_CYRILLIC: \"sr\",\n  SERBIAN_LATIN: \"sr-Latn\",\n  SLOVAK: \"sk\",\n  SLOVENE: \"sl\",\n  SPANISH: \"es\",\n  SWEDISH: \"sv\",\n  TAMIL: \"ta\",\n  TELUGU: \"te\",\n  THAI: \"th\",\n  TURKISH: \"tr\",\n  UKRAINIAN: \"uk\",\n  WELSH: \"cy\",\n} as const;\n\nconst languagesIsoSet = new Set(Object.values(Language) as Array<string>);\n\nfunction isLanguageSupported(lang: string): boolean {\n  return languagesIsoSet.has(lang);\n}\n\nconst languageCodeSet = new Set(Object.values(Language));\n\n/**\n * Type representing the key of the Language object\n */\ntype LanguageKey = keyof typeof Language;\n\ntype Values<T> = T[keyof T];\n\n/**\n * Built-in languages values as strings\n */\ntype LanguageString = Values<typeof Language>;\n\nfunction getBrowserLanguage(): LanguageString {\n  if (typeof navigator === \"undefined\") {\n    return Intl.DateTimeFormat()\n      .resolvedOptions()\n      .locale.split(\"-\")[0] as LanguageString;\n  }\n\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0]))\n  ).filter((l) => languageCodeSet.has(l as LanguageString));\n\n  return canditatelangs.length\n    ? (canditatelangs[0] as LanguageString)\n    : Language.LATIN;\n}\n\nexport {\n  Language,\n  LanguageString,\n  LanguageKey,\n  getBrowserLanguage,\n  isLanguageSupported,\n};\n","import EventEmitter from \"events\";\nimport { Language, LanguageString } from \"./language\";\nimport { config as clientConfig, FetchFunction } from \"@maptiler/client\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Unit } from \"./unit\";\n\nexport const MAPTILER_SESSION_ID = uuidv4();\n\n/**\n * Configuration class for the SDK\n */\nclass SdkConfig extends EventEmitter {\n  /**\n   * The primary language. By default, the language of the web browser is used.\n   */\n  primaryLanguage: LanguageString | null = Language.AUTO;\n\n  /**\n   * The secondary language, to overwrite the default language defined in the map style.\n   * This settings is highly dependant on the style compatibility and may not work in most cases.\n   */\n  secondaryLanguage: LanguageString | null = null;\n\n  /**\n   * Setting on whether of not the SDK runs with a session logic.\n   * A \"session\" is started at the initialization of the SDK and finished when the browser\n   * page is being refreshed.\n   * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n   * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n   */\n  session = true;\n\n  /**\n   * Unit to be used\n   */\n  private _unit: Unit = \"metric\";\n\n  /**\n   * MapTiler Cloud API key\n   */\n  private _apiKey = \"\";\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Set the unit system\n   */\n  set unit(u: Unit) {\n    this._unit = u;\n    this.emit(\"unit\", u);\n  }\n\n  /**\n   * Get the unit system\n   */\n  get unit(): Unit {\n    return this._unit;\n  }\n\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k: string) {\n    this._apiKey = k;\n    clientConfig.apiKey = k;\n    this.emit(\"apiKey\", k);\n  }\n\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey(): string {\n    return this._apiKey;\n  }\n\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f: FetchFunction) {\n    clientConfig.fetch = f;\n  }\n\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch(): FetchFunction | null {\n    return clientConfig.fetch;\n  }\n}\n\nconst config = new SdkConfig();\n\nexport { config, SdkConfig };\n","import { Language } from \"./language\";\n\n/**\n * Some default settings for the SDK\n */\nconst defaults = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  rtlPluginURL:\n    \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: Language.AUTO,\n  secondaryLanguage: Language.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\",\n};\n\nObject.freeze(defaults);\n\nexport { defaults };\n","/**\n * This is an extension of MapLibre LogoControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class LogoControl extends maplibregl.LogoControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","import maplibregl from \"maplibre-gl\";\nimport type { LogoOptions as LogoOptionsML } from \"maplibre-gl\";\nimport { defaults } from \"./defaults\";\nimport { Map } from \"./Map\";\nimport { LogoControl } from \"./LogoControl\";\n\ntype LogoOptions = LogoOptionsML & {\n  logoURL?: string;\n  linkURL?: string;\n};\n\n/**\n * This LogoControl extends the MapLibre LogoControl but instead can use any image URL and\n * any link URL. By default this is using MapTiler logo and URL.\n */\nexport class MaptilerLogoControl extends LogoControl {\n  private logoURL = \"\";\n  private linkURL = \"\";\n\n  constructor(options: LogoOptions = {}) {\n    super(options);\n\n    this.logoURL = options.logoURL ?? defaults.maptilerLogoURL;\n    this.linkURL = options.linkURL ?? defaults.maptilerURL;\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this._map = map;\n    this._compact = this.options && this.options.compact;\n    this._container = window.document.createElement(\"div\");\n    this._container.className = \"maplibregl-ctrl\";\n    const anchor = window.document.createElement(\"a\");\n    anchor.style.backgroundRepeat = \"no-repeat\";\n    anchor.style.cursor = \"pointer\";\n    anchor.style.display = \"block\";\n    anchor.style.height = \"23px\";\n    anchor.style.margin = \"0 0 -4px -4px\";\n    anchor.style.overflow = \"hidden\";\n    anchor.style.width = \"88px\";\n    anchor.style.backgroundImage = `url(${this.logoURL})`;\n    anchor.style.backgroundSize = \"100px 30px\";\n    anchor.style.width = \"100px\";\n    anchor.style.height = \"30px\";\n\n    anchor.target = \"_blank\";\n    anchor.rel = \"noopener\";\n    anchor.href = this.linkURL;\n    anchor.setAttribute(\"aria-label\", \"MapTiler logo\");\n    anchor.setAttribute(\"rel\", \"noopener\");\n    this._container.appendChild(anchor);\n    this._container.style.display = \"block\";\n\n    this._map.on(\"resize\", this._updateCompact);\n    this._updateCompact();\n\n    return this._container;\n  }\n}\n","import maplibregl from \"maplibre-gl\";\nimport type {\n  RequestParameters,\n  ResourceType,\n  RequestTransformFunction,\n} from \"maplibre-gl\";\nimport { defaults } from \"./defaults\";\nimport { config } from \"./config\";\nimport { MAPTILER_SESSION_ID } from \"./config\";\n\nexport function enableRTL() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if (maplibregl.getRTLTextPluginStatus() === \"unavailable\") {\n    maplibregl.setRTLTextPlugin(\n      defaults.rtlPluginURL,\n      null,\n      true // Lazy load the plugin\n    );\n  }\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/util.ts#L223\nexport function bindAll(fns: Array<string>, context: any): void {\n  fns.forEach((fn) => {\n    if (!context[fn]) {\n      return;\n    }\n    context[fn] = context[fn].bind(context);\n  });\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/dom.ts#L22\nexport function DOMcreate<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  className?: string,\n  container?: HTMLElement\n): HTMLElementTagNameMap[K] {\n  const el = window.document.createElement(tagName);\n  if (className !== undefined) el.className = className;\n  if (container) container.appendChild(el);\n  return el;\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/dom.ts#L111\nexport function DOMremove(node: HTMLElement) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * This function is meant to be used as transformRequest by any Map instance created.\n * It adds the session ID as well as the MapTiler Cloud key from the config to all the requests\n * performed on MapTiler Cloud servers.\n * @param url\n * @param resourceType\n * @returns\n */\nexport function maptilerCloudTransformRequest(\n  url: string,\n  resourceType?: ResourceType\n): RequestParameters {\n  let reqUrl = null;\n\n  try {\n    // The URL is expected to be absolute.\n    // Yet, if it's local we just return it without assuming a 'base' url (in the URL constructor)\n    // and we let the URL be locally resolved with a potential base path.\n    reqUrl = new URL(url);\n  } catch (e) {\n    return {\n      url,\n    };\n  }\n\n  if (reqUrl.host === defaults.maptilerApiHost) {\n    if (!reqUrl.searchParams.has(\"key\")) {\n      reqUrl.searchParams.append(\"key\", config.apiKey);\n    }\n\n    if (config.session) {\n      reqUrl.searchParams.append(\"mtsid\", MAPTILER_SESSION_ID);\n    }\n  }\n\n  return {\n    url: reqUrl.href,\n  };\n}\n\n/**\n * This combines a user-defined tranformRequest function (optionnal)\n * with the MapTiler Cloud-specific one: maptilerCloudTransformRequest\n * @param userDefinedRTF\n * @returns\n */\nexport function combineTransformRequest(\n  userDefinedRTF: RequestTransformFunction = null\n): RequestTransformFunction {\n  return function (\n    url: string,\n    resourceType?: ResourceType\n  ): RequestParameters {\n    if (userDefinedRTF) {\n      const rp = userDefinedRTF(url, resourceType);\n      const rp2 = maptilerCloudTransformRequest(rp.url);\n\n      return {\n        ...rp,\n        ...rp2,\n      };\n    } else {\n      return maptilerCloudTransformRequest(url);\n    }\n  };\n}\n","import {\n  MapStyle,\n  ReferenceMapStyle,\n  MapStyleVariant,\n  mapStylePresetList,\n  expandMapStyle,\n} from \"@maptiler/client\";\n\nexport function styleToStyle(\n  style:\n    | string\n    | ReferenceMapStyle\n    | MapStyleVariant\n    | maplibregl.StyleSpecification\n    | null\n    | undefined\n): string | maplibregl.StyleSpecification {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID]\n      .getDefaultVariant()\n      .getExpandedStyleURL();\n  }\n\n  // If the provided style is a shorthand (eg. \"streets-v2\") or a full style URL\n  if (typeof style === \"string\" || style instanceof String) {\n    if (!style.startsWith(\"http\") && style.toLowerCase().includes(\".json\")) {\n      // If a style does not start by http but still contains the extension \".json\"\n      // we assume it's a relative path to a style json file\n      return style as string;\n    } else {\n      return expandMapStyle(style);\n    }\n  }\n\n  if (style instanceof MapStyleVariant) {\n    return style.getExpandedStyleURL();\n  }\n\n  if (style instanceof ReferenceMapStyle) {\n    return (style.getDefaultVariant() as MapStyleVariant).getExpandedStyleURL();\n  }\n\n  return style as maplibregl.StyleSpecification;\n}\n","import { bindAll, DOMcreate, DOMremove } from \"./tools\";\n\nimport { Map } from \"./Map\";\nimport maplibregl from \"maplibre-gl\";\n\n/**\n * A `MaptilerTerrainControl` control adds a button to turn terrain on and off\n * by triggering the terrain logic that is already deployed in the Map object.\n */\nexport class MaptilerTerrainControl implements maplibregl.IControl {\n  _map: Map;\n  _container: HTMLElement;\n  _terrainButton: HTMLButtonElement;\n\n  constructor() {\n    bindAll([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n\n  onAdd(map: Map) {\n    this._map = map;\n    this._container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    this._terrainButton = DOMcreate(\n      \"button\",\n      \"maplibregl-ctrl-terrain\",\n      this._container\n    );\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\n      \"aria-hidden\",\n      \"true\"\n    );\n    this._terrainButton.type = \"button\";\n    this._terrainButton.addEventListener(\"click\", this._toggleTerrain);\n\n    this._updateTerrainIcon();\n    this._map.on(\"terrain\", this._updateTerrainIcon);\n    return this._container;\n  }\n\n  onRemove() {\n    DOMremove(this._container);\n    this._map.off(\"terrain\", this._updateTerrainIcon);\n    this._map = undefined;\n  }\n\n  _toggleTerrain() {\n    if (this._map.hasTerrain()) {\n      this._map.disableTerrain();\n    } else {\n      this._map.enableTerrain();\n    }\n\n    this._updateTerrainIcon();\n  }\n\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\");\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\");\n    // if (this._map.terrain) {\n    if (this._map.hasTerrain()) {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.disableTerrain\"\n      );\n    } else {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.enableTerrain\"\n      );\n    }\n  }\n}\n","/**\n * This is an extension of MapLibre NavigationControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class NavigationControl extends maplibregl.NavigationControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","import { NavigationControl } from \"./NavigationControl\";\n\ntype HTMLButtonElementPlus = HTMLButtonElement & {\n  clickFunction: (e?: any) => unknown;\n};\n\nexport class MaptilerNavigationControl extends NavigationControl {\n  constructor() {\n    super({\n      showCompass: true,\n      showZoom: true,\n      visualizePitch: true,\n    });\n\n    // Removing the default click event\n    this._compass.removeEventListener(\n      \"click\",\n      (this._compass as HTMLButtonElementPlus).clickFunction\n    );\n\n    // Adding custom click event\n    this._compass.addEventListener(\"click\", (e) => {\n      {\n        const currentPitch = this._map.getPitch();\n        if (currentPitch === 0) {\n          this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) });\n        } else {\n          if (this.options.visualizePitch) {\n            this._map.resetNorthPitch({}, { originalEvent: e });\n          } else {\n            this._map.resetNorth({}, { originalEvent: e });\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(\n    className: string,\n    fn: (e?: any) => unknown\n  ): HTMLButtonElementPlus {\n    const button = super._createButton(className, fn) as HTMLButtonElementPlus;\n    button.clickFunction = fn;\n    return button;\n  }\n\n  /**\n   * Overloading: Limit how flat the compass icon can get\n   */\n  _rotateCompassArrow() {\n    const rotate = this.options.visualizePitch\n      ? `scale(${Math.min(\n          1.5,\n          1 /\n            Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)\n        )}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${\n          this._map.transform.angle * (180 / Math.PI)\n        }deg)`\n      : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n\n    this._compassIcon.style.transform = rotate;\n  }\n}\n","/**\n * This is an extension of MapLibre GeolocateControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class GeolocateControl extends maplibregl.GeolocateControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","import type { LngLatLike } from \"maplibre-gl\";\nimport maplibregl from \"maplibre-gl\";\nimport { GeolocateControl } from \"./GeolocateControl\";\nimport { DOMcreate } from \"./tools\";\n\nconst Marker = maplibregl.Marker;\nconst LngLat = maplibregl.LngLat;\nconst LngLatBounds = maplibregl.LngLatBounds;\n\n/**\n * The MaptilerGeolocateControl is an extension of the original GeolocateControl\n * with a few changes. In this version, the active mode persists as long as the\n * location is still centered. This means it's robust to rotation, pitch and zoom.\n *\n */\nexport class MaptilerGeolocateControl extends GeolocateControl {\n  private lastUpdatedCenter = new LngLat(0, 0);\n\n  /**\n   * Update the camera location to center on the current position\n   *\n   * @param {Position} position the Geolocation API Position\n   * @private\n   */\n  _updateCamera(position: GeolocationPosition) {\n    const center = new LngLat(\n      position.coords.longitude,\n      position.coords.latitude\n    );\n    const radius = position.coords.accuracy;\n    const bearing = this._map.getBearing();\n    const options = {\n      bearing,\n      ...this.options.fitBoundsOptions,\n      linear: true,\n    };\n\n    const currentMapZoom = this._map.getZoom();\n\n    if (currentMapZoom > this.options.fitBoundsOptions.maxZoom) {\n      options.zoom = currentMapZoom;\n    }\n\n    this._map.fitBounds(LngLatBounds.fromLngLat(center, radius), options, {\n      geolocateSource: true, // tag this camera change so it won't cause the control to change to background state\n    });\n\n    let hasFittingBeenDisrupted = false;\n\n    const flagFittingDisruption = () => {\n      hasFittingBeenDisrupted = true;\n    };\n\n    this._map.once(\"click\", flagFittingDisruption);\n    this._map.once(\"dblclick\", flagFittingDisruption);\n    this._map.once(\"dragstart\", flagFittingDisruption);\n    this._map.once(\"mousedown\", flagFittingDisruption);\n    this._map.once(\"touchstart\", flagFittingDisruption);\n    this._map.once(\"wheel\", flagFittingDisruption);\n\n    this._map.once(\"moveend\", () => {\n      // Removing the events if not used\n      this._map.off(\"click\", flagFittingDisruption);\n      this._map.off(\"dblclick\", flagFittingDisruption);\n      this._map.off(\"dragstart\", flagFittingDisruption);\n      this._map.off(\"mousedown\", flagFittingDisruption);\n      this._map.off(\"touchstart\", flagFittingDisruption);\n      this._map.off(\"wheel\", flagFittingDisruption);\n\n      if (hasFittingBeenDisrupted) {\n        return;\n      }\n\n      this.lastUpdatedCenter = this._map.getCenter();\n    });\n  }\n\n  _setupUI(supported: boolean) {\n    this.lastUpdatedCenter = this._map.getCenter();\n\n    this._container.addEventListener(\"contextmenu\", (e: MouseEvent) =>\n      e.preventDefault()\n    );\n    this._geolocateButton = DOMcreate(\n      \"button\",\n      \"maplibregl-ctrl-geolocate\",\n      this._container\n    );\n    DOMcreate(\n      \"span\",\n      \"maplibregl-ctrl-icon\",\n      this._geolocateButton\n    ).setAttribute(\"aria-hidden\", \"true\");\n    this._geolocateButton.type = \"button\";\n\n    if (supported === false) {\n      // warnOnce('Geolocation support is not available so the GeolocateControl will be disabled.');\n      const title = this._map._getUIString(\n        \"GeolocateControl.LocationNotAvailable\"\n      );\n      this._geolocateButton.disabled = true;\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    } else {\n      const title = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    }\n\n    if (this.options.trackUserLocation) {\n      this._geolocateButton.setAttribute(\"aria-pressed\", \"false\");\n      this._watchState = \"OFF\";\n    }\n\n    // when showUserLocation is enabled, keep the Geolocate button disabled until the device location marker is setup on the map\n    if (this.options.showUserLocation) {\n      this._dotElement = DOMcreate(\"div\", \"maplibregl-user-location-dot\");\n\n      this._userLocationDotMarker = new Marker(this._dotElement);\n\n      this._circleElement = DOMcreate(\n        \"div\",\n        \"maplibregl-user-location-accuracy-circle\"\n      );\n      this._accuracyCircleMarker = new Marker({\n        element: this._circleElement,\n        pitchAlignment: \"map\",\n      });\n\n      if (this.options.trackUserLocation) this._watchState = \"OFF\";\n\n      this._map.on(\"move\", this._onZoom);\n    }\n\n    this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this));\n\n    this._setup = true;\n\n    // when the camera is changed (and it's not as a result of the Geolocation Control) change\n    // the watch mode to background watch, so that the marker is updated but not the camera.\n    // Addition: Yet the status change does not occur if the ditance it has moved to is less than\n    // one meter from the last auto-updated position. This is to guarrantee that if the move\n    // is a zoom, rotation or pitch (where the center stays the same) then we can keep the ACTIVE_LOCK\n    // mode ON.\n    if (this.options.trackUserLocation) {\n      this._map.on(\"moveend\", (event: any) => {\n        const fromResize =\n          event.originalEvent && event.originalEvent.type === \"resize\";\n        const movingDistance = this.lastUpdatedCenter.distanceTo(\n          this._map.getCenter()\n        );\n\n        if (\n          !event.geolocateSource &&\n          this._watchState === \"ACTIVE_LOCK\" &&\n          !fromResize &&\n          movingDistance > 1\n        ) {\n          this._watchState = \"BACKGROUND\";\n          this._geolocateButton.classList.add(\n            \"maplibregl-ctrl-geolocate-background\"\n          );\n          this._geolocateButton.classList.remove(\n            \"maplibregl-ctrl-geolocate-active\"\n          );\n\n          this.fire(new Event(\"trackuserlocationend\"));\n        }\n      });\n    }\n  }\n\n  _updateCircleRadius() {\n    if (\n      this._watchState !== \"BACKGROUND\" &&\n      this._watchState !== \"ACTIVE_LOCK\"\n    ) {\n      return;\n    }\n\n    const lastKnownLocation: LngLatLike = [\n      this._lastKnownPosition.coords.longitude,\n      this._lastKnownPosition.coords.latitude,\n    ];\n\n    const projectedLocation = this._map.project(lastKnownLocation);\n    const a = this._map.unproject([projectedLocation.x, projectedLocation.y]);\n    const b = this._map.unproject([\n      projectedLocation.x + 20,\n      projectedLocation.y,\n    ]);\n    const metersPerPixel = a.distanceTo(b) / 20;\n\n    const circleDiameter = Math.ceil((2.0 * this._accuracy) / metersPerPixel);\n    this._circleElement.style.width = `${circleDiameter}px`;\n    this._circleElement.style.height = `${circleDiameter}px`;\n  }\n\n  _onZoom() {\n    if (this.options.showUserLocation && this.options.showAccuracyCircle) {\n      this._updateCircleRadius();\n    }\n  }\n}\n","/**\n * This is an extension of MapLibre AttributionControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class AttributionControl extends maplibregl.AttributionControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre ScaleControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class ScaleControl extends maplibregl.ScaleControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre FullscreenControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class FullscreenControl extends maplibregl.FullscreenControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","import maplibregl from \"maplibre-gl\";\nimport { Base64 } from \"js-base64\";\nimport type {\n  StyleSpecification,\n  MapOptions as MapOptionsML,\n  ControlPosition,\n  StyleOptions,\n  MapDataEvent,\n  Tile,\n  RasterDEMSourceSpecification,\n  RequestTransformFunction,\n} from \"maplibre-gl\";\nimport { ReferenceMapStyle, MapStyleVariant } from \"@maptiler/client\";\nimport { config, MAPTILER_SESSION_ID, SdkConfig } from \"./config\";\nimport { defaults } from \"./defaults\";\nimport { MaptilerLogoControl } from \"./MaptilerLogoControl\";\nimport { combineTransformRequest, enableRTL } from \"./tools\";\nimport {\n  getBrowserLanguage,\n  isLanguageSupported,\n  Language,\n  LanguageString,\n} from \"./language\";\nimport { styleToStyle } from \"./mapstyle\";\nimport { MaptilerTerrainControl } from \"./MaptilerTerrainControl\";\nimport { MaptilerNavigationControl } from \"./MaptilerNavigationControl\";\nimport { geolocation } from \"@maptiler/client\";\nimport { MaptilerGeolocateControl } from \"./MaptilerGeolocateControl\";\nimport { AttributionControl } from \"./AttributionControl\";\nimport { ScaleControl } from \"./ScaleControl\";\nimport { FullscreenControl } from \"./FullscreenControl\";\n\nfunction sleepAsync(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport type LoadWithTerrainEvent = {\n  type: \"loadWithTerrain\";\n  target: Map;\n  terrain: {\n    source: string;\n    exaggeration: number;\n  };\n};\n\n// StyleSwapOptions is not exported by Maplibre, but we can redefine it (used for setStyle)\nexport type TransformStyleFunction = (\n  previous: StyleSpecification,\n  next: StyleSpecification\n) => StyleSpecification;\n\nexport type StyleSwapOptions = {\n  diff?: boolean;\n  transformStyle?: TransformStyleFunction;\n};\n\nexport const GeolocationType: {\n  POINT: \"POINT\";\n  COUNTRY: \"COUNTRY\";\n} = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\",\n} as const;\n\ntype MapTerrainDataEvent = MapDataEvent & {\n  isSourceLoaded: boolean;\n  tile: Tile;\n  sourceId: string;\n  source: RasterDEMSourceSpecification;\n};\n\n/**\n * Options to provide to the `Map` constructor\n */\nexport type MapOptions = Omit<MapOptionsML, \"style\" | \"maplibreLogo\"> & {\n  /**\n   * Style of the map. Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  style?: ReferenceMapStyle | MapStyleVariant | StyleSpecification | string;\n\n  /**\n   * Define the language of the map. This can be done directly with a language ISO code (eg. \"en\")\n   * or with a built-in shorthand (eg. Language.ENGLISH).\n   * Note that this is equivalent to setting the `config.primaryLanguage` and will overwrite it.\n   */\n  language?: LanguageString;\n\n  /**\n   * Define the MapTiler Cloud API key to be used. This is strictly equivalent to setting\n   * `config.apiKey` and will overwrite it.\n   */\n  apiKey?: string;\n\n  /**\n   * Shows or hides the MapTiler logo in the bottom left corner.\n   *\n   * For paid plans:\n   * - `true` shows MapTiler logo\n   * - `false` hodes MapTiler logo\n   * - default: `false` (hide)\n   *\n   * For free plans: MapTiler logo always shows, regardless of the value.\n   */\n  maptilerLogo?: boolean;\n\n  /**\n   * Enables 3D terrain if `true`. (default: `false`)\n   */\n  terrain?: boolean;\n\n  /**\n   * Exaggeration factor of the terrain. (default: `1`, no exaggeration)\n   */\n  terrainExaggeration?: number;\n\n  /**\n   * Show the navigation control. (default: `true`, will hide if `false`)\n   */\n  navigationControl?: boolean | ControlPosition;\n\n  /**\n   * Show the terrain control. (default: `false`, will show if `true`)\n   */\n  terrainControl?: boolean | ControlPosition;\n\n  /**\n   * Show the geolocate control. (default: `true`, will hide if `false`)\n   */\n  geolocateControl?: boolean | ControlPosition;\n\n  /**\n   * Show the scale control. (default: `false`, will show if `true`)\n   */\n  scaleControl?: boolean | ControlPosition;\n\n  /**\n   * Show the full screen control. (default: `false`, will show if `true`)\n   */\n  fullscreenControl?: boolean | ControlPosition;\n\n  /**\n   * Method to position the map at a given geolocation. Only if:\n   * - `hash` is `false`\n   * - `center` is not provided\n   *\n   * If the value is `true` of `\"POINT\"` (given by `GeolocationType.POINT`) then the positionning uses the MapTiler Cloud\n   * Geolocation to find the non-GPS location point.\n   * The zoom level can be provided in the `Map` constructor with the `zoom` option or will be `13` if not provided.\n   *\n   * If the value is `\"COUNTRY\"` (given by `GeolocationType.COUNTRY`) then the map is centered around the bounding box of the country.\n   * In this case, the `zoom` option will be ignored.\n   *\n   * If the value is `false`, no geolocation is performed and the map centering and zooming depends on other options or on\n   * the built-in defaults.\n   *\n   * If this option is non-false and the options `center` is also provided, then `center` prevails.\n   *\n   * Default: `false`\n   */\n  geolocate?: (typeof GeolocationType)[keyof typeof GeolocationType] | boolean;\n};\n\n/**\n * The Map class can be instanciated to display a map in a `<div>`\n */\nexport class Map extends maplibregl.Map {\n  private isTerrainEnabled = false;\n  private terrainExaggeration = 1;\n  private primaryLanguage: LanguageString | null = null;\n  private secondaryLanguage: LanguageString | null = null;\n  private terrainGrowing = false;\n  private terrainFlattening = false;\n\n  constructor(options: MapOptions) {\n    if (options.apiKey) {\n      config.apiKey = options.apiKey;\n    }\n\n    const style = styleToStyle(options.style);\n    const hashPreConstructor = location.hash;\n\n    if (!config.apiKey) {\n      console.warn(\n        \"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\"\n      );\n    }\n\n    // calling the map constructor with full length style\n    super({\n      ...options,\n      style,\n      maplibreLogo: false,\n      transformRequest: combineTransformRequest(options.transformRequest),\n    });\n\n    this.primaryLanguage = options.language ?? config.primaryLanguage;\n    this.secondaryLanguage = config.secondaryLanguage;\n    this.terrainExaggeration =\n      options.terrainExaggeration ?? this.terrainExaggeration;\n\n    // Map centering and geolocation\n    this.once(\"styledata\", async () => {\n      // Not using geolocation centering if...\n\n      // the geolcoate option is not provided or is falsy\n      if (!options.geolocate) {\n        return;\n      }\n\n      // ... a center is provided in options\n      if (options.center) {\n        return;\n      }\n\n      // ... the hash option is enabled and a hash is present in the URL\n      if (options.hash && !!hashPreConstructor) {\n        return;\n      }\n\n      // If the geolocation is set to COUNTRY:\n      try {\n        if (options.geolocate === GeolocationType.COUNTRY) {\n          await this.fitToIpBounds();\n          return;\n        }\n      } catch (e) {\n        // not raising\n        console.warn(e.message);\n      }\n\n      // As a fallback, we want to center the map on the visitor. First with IP geolocation...\n      let ipLocatedCameraHash = null;\n      try {\n        await this.centerOnIpPoint(options.zoom);\n        ipLocatedCameraHash = this.getCameraHash();\n      } catch (e) {\n        // not raising\n        console.warn(e.message);\n      }\n\n      // A more precise localization\n\n      // This more advanced localization is commented out because the easeTo animation\n      // triggers an error if the terrain grow is enabled (due to being nable to project the center while moving)\n\n      // Then, the get a more precise location, we rely on the browser location, but only if it was already granted\n      // before (we don't want to ask wih a popup at launch time)\n      const locationResult = await navigator.permissions.query({\n        name: \"geolocation\",\n      });\n\n      if (locationResult.state === \"granted\") {\n        navigator.geolocation.getCurrentPosition(\n          // success callback\n          (data) => {\n            // If the user has already moved since the ip location, then we no longer want to move the center\n            if (ipLocatedCameraHash !== this.getCameraHash()) {\n              return;\n            }\n\n            if (this.terrain) {\n              this.easeTo({\n                center: [data.coords.longitude, data.coords.latitude],\n                zoom: options.zoom || 12,\n                duration: 2000,\n              });\n            } else {\n              this.once(\"terrain\", () => {\n                this.easeTo({\n                  center: [data.coords.longitude, data.coords.latitude],\n                  zoom: options.zoom || 12,\n                  duration: 2000,\n                });\n              });\n            }\n          },\n\n          // error callback\n          null,\n\n          // options\n          {\n            maximumAge: 24 * 3600 * 1000, // a day in millisec\n            timeout: 5000, // milliseconds\n            enableHighAccuracy: false,\n          }\n        );\n      }\n    });\n\n    // If the config includes language changing, we must update the map language\n    this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n      this.setSecondaryLanguage(this.secondaryLanguage);\n    });\n\n    // this even is in charge of reaplying the terrain elevation after the\n    // style has changed because depending on the src/tgt style,\n    // the style logic is not always able to resolve the application of terrain\n    this.on(\"styledata\", () => {\n      // the styling resolver did no manage to reaply the terrain,\n      // so let's reload it\n      if (this.getTerrain() === null && this.isTerrainEnabled) {\n        this.enableTerrain(this.terrainExaggeration);\n      }\n    });\n\n    // load the Right-to-Left text plugin (will happen only once)\n    this.once(\"load\", async () => {\n      enableRTL();\n    });\n\n    // Update logo and attibution\n    this.once(\"load\", async () => {\n      let tileJsonContent = { logo: null };\n\n      try {\n        const possibleSources = Object.keys(this.style.sourceCaches)\n          .map((sourceName) => this.getSource(sourceName))\n          .filter(\n            (s: any) =>\n              typeof s.url === \"string\" && s.url.includes(\"tiles.json\")\n          );\n\n        const styleUrl = new URL(\n          (possibleSources[0] as maplibregl.VectorTileSource).url\n        );\n\n        if (!styleUrl.searchParams.has(\"key\")) {\n          styleUrl.searchParams.append(\"key\", config.apiKey);\n        }\n\n        const tileJsonRes = await fetch(styleUrl.href);\n        tileJsonContent = await tileJsonRes.json();\n      } catch (e) {\n        // No tiles.json found (should not happen on maintained styles)\n      }\n\n      // The attribution and logo must show when required\n      if (\"logo\" in tileJsonContent && tileJsonContent.logo) {\n        const logoURL: string = tileJsonContent.logo;\n\n        this.addControl(\n          new MaptilerLogoControl({ logoURL }),\n          options.logoPosition\n        );\n\n        // if attribution in option is `false` but the the logo shows up in the tileJson, then the attribution must show anyways\n        if (options.attributionControl === false) {\n          this.addControl(\n            new AttributionControl({\n              customAttribution: options.customAttribution,\n            })\n          );\n        }\n      } else if (options.maptilerLogo) {\n        this.addControl(new MaptilerLogoControl(), options.logoPosition);\n      }\n\n      // the other controls at init time but be after\n      // (due to the async nature of logo control)\n\n      // By default, no scale control\n      if (options.scaleControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.scaleControl === true || options.scaleControl === undefined\n            ? \"bottom-right\"\n            : options.scaleControl\n        ) as ControlPosition;\n\n        const scaleControl = new ScaleControl({ unit: config.unit });\n        this.addControl(scaleControl, position);\n        config.on(\"unit\", (unit) => {\n          scaleControl.setUnit(unit);\n        });\n      }\n\n      if (options.navigationControl !== false) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.navigationControl === true ||\n          options.navigationControl === undefined\n            ? \"top-right\"\n            : options.navigationControl\n        ) as ControlPosition;\n        this.addControl(new MaptilerNavigationControl(), position);\n      }\n\n      if (options.geolocateControl !== false) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.geolocateControl === true ||\n          options.geolocateControl === undefined\n            ? \"top-right\"\n            : options.geolocateControl\n        ) as ControlPosition;\n\n        this.addControl(\n          // new maplibregl.GeolocateControl({\n          new MaptilerGeolocateControl({\n            positionOptions: {\n              enableHighAccuracy: true,\n              maximumAge: 0,\n              timeout: 6000 /* 6 sec */,\n            },\n            fitBoundsOptions: {\n              maxZoom: 15,\n            },\n            trackUserLocation: true,\n            showAccuracyCircle: true,\n            showUserLocation: true,\n          }),\n          position\n        );\n      }\n\n      if (options.terrainControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.terrainControl === true ||\n          options.terrainControl === undefined\n            ? \"top-right\"\n            : options.terrainControl\n        ) as ControlPosition;\n        this.addControl(new MaptilerTerrainControl(), position);\n      }\n\n      // By default, no fullscreen control\n      if (options.fullscreenControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.fullscreenControl === true ||\n          options.fullscreenControl === undefined\n            ? \"top-right\"\n            : options.fullscreenControl\n        ) as ControlPosition;\n\n        this.addControl(new FullscreenControl({}), position);\n      }\n    });\n\n    // Creating a custom event: \"loadWithTerrain\"\n    // that fires only once when both:\n    // - the map has full loaded (corresponds to the the \"load\" event)\n    // - the terrain has loaded (corresponds to the \"terrain\" event with terrain beion non-null)\n    // This custom event is necessary to wait for when the map is instanciated with `terrain: true`\n    // and some animation (flyTo, easeTo) are running from the begining.\n    let loadEventTriggered = false;\n    let terrainEventTriggered = false;\n    let terrainEventData: LoadWithTerrainEvent = null;\n\n    this.once(\"load\", (_) => {\n      loadEventTriggered = true;\n      if (terrainEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    });\n\n    const terrainCallback = (evt) => {\n      if (!evt.terrain) return;\n      terrainEventTriggered = true;\n      terrainEventData = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: evt.terrain,\n      };\n      this.off(\"terrain\", terrainCallback);\n\n      if (loadEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData as LoadWithTerrainEvent);\n      }\n    };\n\n    this.on(\"terrain\", terrainCallback);\n\n    // enable 3D terrain if provided in options\n    if (options.terrain) {\n      this.enableTerrain(\n        options.terrainExaggeration ?? this.terrainExaggeration\n      );\n    }\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  async onLoadAsync() {\n    return new Promise<Map>((resolve, reject) => {\n      if (this.loaded()) {\n        return resolve(this);\n      }\n\n      this.once(\"load\", (_) => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  async onLoadWithTerrainAsync() {\n    return new Promise<Map>((resolve, reject) => {\n      if (this.loaded() && this.terrain) {\n        return resolve(this);\n      }\n\n      this.once(\"loadWithTerrain\", (_) => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   * @param style\n   * @param options\n   * @returns\n   */\n  setStyle(\n    style: ReferenceMapStyle | MapStyleVariant | StyleSpecification | string,\n    options?: StyleSwapOptions & StyleOptions\n  ) {\n    return super.setStyle(styleToStyle(style), options);\n  }\n\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   * This function is a short for `.setPrimaryLanguage()`\n   * @param language\n   */\n  setLanguage(language: LanguageString = defaults.primaryLanguage) {\n    if (language === Language.AUTO) {\n      return this.setLanguage(getBrowserLanguage());\n    }\n    this.setPrimaryLanguage(language);\n  }\n\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   * @param language\n   */\n  setPrimaryLanguage(language: LanguageString = defaults.primaryLanguage) {\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\n        \"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\"\n      );\n      return;\n    }\n\n    if (!isLanguageSupported(language as string)) {\n      return;\n    }\n\n    this.primaryLanguage = language;\n\n    this.onStyleReady(() => {\n      if (language === Language.AUTO) {\n        return this.setPrimaryLanguage(getBrowserLanguage());\n      }\n\n      const layers = this.getStyle().layers;\n\n      // detects pattern like \"{name:somelanguage}\" with loose spacing\n      const strLanguageRegex = /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n\n      // detects pattern like \"name:somelanguage\" with loose spacing\n      const strLanguageInArrayRegex = /^\\s*name\\s*(:\\s*(\\S*))?\\s*$/;\n\n      // for string based bilingual lang such as \"{name:latin}  {name:nonlatin}\" or \"{name:latin}  {name}\"\n      const strBilingualRegex =\n        /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}(\\s*){\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n\n      // Regex to capture when there are more info, such as mountains elevation with unit m/ft\n      const strMoreInfoRegex = /^(.*)({\\s*name\\s*(:\\s*(\\S*))?\\s*})(.*)$/;\n\n      const langStr = language ? `name:${language}` : \"name\"; // to handle local lang\n      const replacer = [\n        \"case\",\n        [\"has\", langStr],\n        [\"get\", langStr],\n        [\"get\", \"name\"],\n      ];\n\n      for (let i = 0; i < layers.length; i += 1) {\n        const layer = layers[i];\n        const layout = layer.layout;\n\n        if (!layout) {\n          continue;\n        }\n\n        if (!layout[\"text-field\"]) {\n          continue;\n        }\n\n        const textFieldLayoutProp = this.getLayoutProperty(\n          layer.id,\n          \"text-field\"\n        );\n\n        // Note:\n        // The value of the 'text-field' property can take multiple shape;\n        // 1. can be an array with 'concat' on its first element (most likely means bilingual)\n        // 2. can be an array with 'get' on its first element (monolingual)\n        // 3. can be a string of shape '{name:latin}'\n        // 4. can be a string referencing another prop such as '{housenumber}' or '{ref}'\n        //\n        // The case 1, 2 and 3 will be updated while maintaining their original type and shape.\n        // The case 3 will not be updated\n\n        let regexMatch;\n\n        // This is case 1\n        if (\n          Array.isArray(textFieldLayoutProp) &&\n          textFieldLayoutProp.length >= 2 &&\n          textFieldLayoutProp[0].trim().toLowerCase() === \"concat\"\n        ) {\n          const newProp = textFieldLayoutProp.slice(); // newProp is Array\n          // The style could possibly have defined more than 2 concatenated language strings but we only want to edit the first\n          // The style could also define that there are more things being concatenated and not only languages\n\n          for (let j = 0; j < textFieldLayoutProp.length; j += 1) {\n            const elem = textFieldLayoutProp[j];\n\n            // we are looking for an elem of shape '{name:somelangage}' (string) of `[\"get\", \"name:somelanguage\"]` (array)\n\n            // the entry of of shape '{name:somelangage}', possibly with loose spacing\n            if (\n              (typeof elem === \"string\" || elem instanceof String) &&\n              strLanguageRegex.exec(elem.toString())\n            ) {\n              newProp[j] = replacer;\n              break; // we just want to update the primary language\n            }\n            // the entry is of an array of shape `[\"get\", \"name:somelanguage\"]`\n            else if (\n              Array.isArray(elem) &&\n              elem.length >= 2 &&\n              elem[0].trim().toLowerCase() === \"get\" &&\n              strLanguageInArrayRegex.exec(elem[1].toString())\n            ) {\n              newProp[j] = replacer;\n              break; // we just want to update the primary language\n            } else if (\n              Array.isArray(elem) &&\n              elem.length === 4 &&\n              elem[0].trim().toLowerCase() === \"case\"\n            ) {\n              newProp[j] = replacer;\n              break; // we just want to update the primary language\n            }\n          }\n\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        }\n\n        // This is case 2\n        else if (\n          Array.isArray(textFieldLayoutProp) &&\n          textFieldLayoutProp.length >= 2 &&\n          textFieldLayoutProp[0].trim().toLowerCase() === \"get\" &&\n          strLanguageInArrayRegex.exec(textFieldLayoutProp[1].toString())\n        ) {\n          const newProp = replacer;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        }\n\n        // This is case 3\n        else if (\n          (typeof textFieldLayoutProp === \"string\" ||\n            textFieldLayoutProp instanceof String) &&\n          strLanguageRegex.exec(textFieldLayoutProp.toString())\n        ) {\n          const newProp = replacer;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if (\n          Array.isArray(textFieldLayoutProp) &&\n          textFieldLayoutProp.length === 4 &&\n          textFieldLayoutProp[0].trim().toLowerCase() === \"case\"\n        ) {\n          const newProp = replacer;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if (\n          (typeof textFieldLayoutProp === \"string\" ||\n            textFieldLayoutProp instanceof String) &&\n          (regexMatch = strBilingualRegex.exec(\n            textFieldLayoutProp.toString()\n          )) !== null\n        ) {\n          const newProp = `{${langStr}}${regexMatch[3]}{name${\n            regexMatch[4] || \"\"\n          }}`;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        } else if (\n          (typeof textFieldLayoutProp === \"string\" ||\n            textFieldLayoutProp instanceof String) &&\n          (regexMatch = strMoreInfoRegex.exec(\n            textFieldLayoutProp.toString()\n          )) !== null\n        ) {\n          const newProp = `${regexMatch[1]}{${langStr}}${regexMatch[5]}`;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        }\n      }\n    });\n  }\n\n  /**\n   * Define the secondary language of the map. Note that this is not supported by all the map styles\n   * Note that most styles do not allow a secondary language and this function only works if the style allows (no force adding)\n   * @param language\n   */\n  setSecondaryLanguage(language: LanguageString = defaults.secondaryLanguage) {\n    // Using the lock flag as a primaty language also applies to the secondary\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\n        \"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\"\n      );\n      return;\n    }\n\n    if (!isLanguageSupported(language as string)) {\n      return;\n    }\n\n    this.secondaryLanguage = language;\n\n    this.onStyleReady(() => {\n      if (language === Language.AUTO) {\n        return this.setSecondaryLanguage(getBrowserLanguage());\n      }\n\n      const layers = this.getStyle().layers;\n\n      // detects pattern like \"{name:somelanguage}\" with loose spacing\n      const strLanguageRegex = /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n\n      // detects pattern like \"name:somelanguage\" with loose spacing\n      const strLanguageInArrayRegex = /^\\s*name\\s*(:\\s*(\\S*))?\\s*$/;\n\n      // for string based bilingual lang such as \"{name:latin}  {name:nonlatin}\" or \"{name:latin}  {name}\"\n      const strBilingualRegex =\n        /^\\s*{\\s*name\\s*(:\\s*(\\S*))?\\s*}(\\s*){\\s*name\\s*(:\\s*(\\S*))?\\s*}$/;\n\n      let regexMatch;\n\n      for (let i = 0; i < layers.length; i += 1) {\n        const layer = layers[i];\n        const layout = layer.layout;\n\n        if (!layout) {\n          continue;\n        }\n\n        if (!layout[\"text-field\"]) {\n          continue;\n        }\n\n        const textFieldLayoutProp = this.getLayoutProperty(\n          layer.id,\n          \"text-field\"\n        );\n\n        let newProp;\n\n        // Note:\n        // The value of the 'text-field' property can take multiple shape;\n        // 1. can be an array with 'concat' on its first element (most likely means bilingual)\n        // 2. can be an array with 'get' on its first element (monolingual)\n        // 3. can be a string of shape '{name:latin}'\n        // 4. can be a string referencing another prop such as '{housenumber}' or '{ref}'\n        //\n        // Only the case 1 will be updated because we don't want to change the styling (read: add a secondary language where the original styling is only displaying 1)\n\n        // This is case 1\n        if (\n          Array.isArray(textFieldLayoutProp) &&\n          textFieldLayoutProp.length >= 2 &&\n          textFieldLayoutProp[0].trim().toLowerCase() === \"concat\"\n        ) {\n          newProp = textFieldLayoutProp.slice(); // newProp is Array\n          // The style could possibly have defined more than 2 concatenated language strings but we only want to edit the first\n          // The style could also define that there are more things being concatenated and not only languages\n\n          let languagesAlreadyFound = 0;\n\n          for (let j = 0; j < textFieldLayoutProp.length; j += 1) {\n            const elem = textFieldLayoutProp[j];\n\n            // we are looking for an elem of shape '{name:somelangage}' (string) of `[\"get\", \"name:somelanguage\"]` (array)\n\n            // the entry of of shape '{name:somelangage}', possibly with loose spacing\n            if (\n              (typeof elem === \"string\" || elem instanceof String) &&\n              strLanguageRegex.exec(elem.toString())\n            ) {\n              if (languagesAlreadyFound === 1) {\n                newProp[j] = `{name:${language}}`;\n                break; // we just want to update the secondary language\n              }\n\n              languagesAlreadyFound += 1;\n            }\n            // the entry is of an array of shape `[\"get\", \"name:somelanguage\"]`\n            else if (\n              Array.isArray(elem) &&\n              elem.length >= 2 &&\n              elem[0].trim().toLowerCase() === \"get\" &&\n              strLanguageInArrayRegex.exec(elem[1].toString())\n            ) {\n              if (languagesAlreadyFound === 1) {\n                newProp[j][1] = `name:${language}`;\n                break; // we just want to update the secondary language\n              }\n\n              languagesAlreadyFound += 1;\n            } else if (\n              Array.isArray(elem) &&\n              elem.length === 4 &&\n              elem[0].trim().toLowerCase() === \"case\"\n            ) {\n              if (languagesAlreadyFound === 1) {\n                newProp[j] = [\"get\", `name:${language}`]; // the situation with 'case' is supposed to only happen with the primary lang\n                break; // but in case a styling also does that for secondary...\n              }\n\n              languagesAlreadyFound += 1;\n            }\n          }\n\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        }\n\n        // the language (both first and second) are defined into a single string model\n        else if (\n          (typeof textFieldLayoutProp === \"string\" ||\n            textFieldLayoutProp instanceof String) &&\n          (regexMatch = strBilingualRegex.exec(\n            textFieldLayoutProp.toString()\n          )) !== null\n        ) {\n          const langStr = language ? `name:${language}` : \"name\"; // to handle local lang\n          newProp = `{name${regexMatch[1] || \"\"}}${regexMatch[3]}{${langStr}}`;\n          this.setLayoutProperty(layer.id, \"text-field\", newProp);\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage(): LanguageString {\n    return this.primaryLanguage;\n  }\n\n  /**\n   * Get the secondary language\n   * @returns\n   */\n  getSecondaryLanguage(): LanguageString {\n    return this.secondaryLanguage;\n  }\n\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration(): number {\n    return this.terrainExaggeration;\n  }\n\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain(): boolean {\n    return this.isTerrainEnabled;\n  }\n\n  private growTerrain(exaggeration, durationMs = 1000) {\n    // This method assumes the terrain is already built\n    if (!this.terrain) {\n      return;\n    }\n\n    const startTime = performance.now();\n    // This is supposedly 0, but it could be something else (e.g. already in the middle of growing, or user defined other)\n    const currentExaggeration = this.terrain.exaggeration;\n    const deltaExaggeration = exaggeration - currentExaggeration;\n\n    // This is again called in a requestAnimationFrame ~loop, until the terrain has grown enough\n    // that it has reached the target\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n\n      // If the flattening animation is triggered while the growing animation\n      // is running, then the flattening animation is stopped\n      if (this.terrainFlattening) {\n        return;\n      }\n\n      // normalized value in interval [0, 1] of where we are currently in the animation loop\n      const positionInLoop = (performance.now() - startTime) / durationMs;\n\n      // The animation goes on until we reached 99% of the growing sequence duration\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = 1 - Math.pow(1 - positionInLoop, 4);\n        const newExaggeration =\n          currentExaggeration + exaggerationFactor * deltaExaggeration;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.terrain.exaggeration = exaggeration;\n      }\n\n      this.triggerRepaint();\n    };\n\n    this.terrainGrowing = true;\n    this.terrainFlattening = false;\n    requestAnimationFrame(updateExaggeration);\n  }\n\n  /**\n   * Enables the 3D terrain visualization\n   * @param exaggeration\n   * @returns\n   */\n  enableTerrain(exaggeration = this.terrainExaggeration) {\n    if (exaggeration < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n\n    // This function is mapped to a map \"data\" event. It checks that the terrain\n    // tiles are loaded and when so, it starts an animation to make the terrain grow\n    const dataEventTerrainGrow = async (evt: MapTerrainDataEvent) => {\n      if (!this.terrain) {\n        return;\n      }\n\n      if (\n        evt.type !== \"data\" ||\n        evt.dataType !== \"source\" ||\n        !(\"source\" in evt)\n      ) {\n        return;\n      }\n\n      if (evt.sourceId !== \"maptiler-terrain\") {\n        return;\n      }\n\n      const source = evt.source;\n\n      if (source.type !== \"raster-dem\") {\n        return;\n      }\n\n      if (!evt.isSourceLoaded) {\n        return;\n      }\n\n      // We shut this event off because we want it to happen only once.\n      // Yet, we cannot use the \"once\" method because only the last event of the series\n      // has `isSourceLoaded` true\n      this.off(\"data\", dataEventTerrainGrow);\n\n      this.growTerrain(exaggeration);\n    };\n\n    // This is put into a function so that it can be called regardless\n    // of the loading state of _this_ the map instance\n    const addTerrain = () => {\n      // When style is changed,\n      this.isTerrainEnabled = true;\n      this.terrainExaggeration = exaggeration;\n\n      // Mapping it to the \"data\" event so that we can check that the terrain\n      // growing starts only when terrain tiles are loaded (to reduce glitching)\n      this.on(\"data\", dataEventTerrainGrow);\n\n      this.addSource(defaults.terrainSourceId, {\n        type: \"raster-dem\",\n        url: defaults.terrainSourceURL,\n      });\n\n      // Setting up the terrain with a 0 exaggeration factor\n      // so it loads ~seamlessly and then can grow from there\n      this.setTerrain({\n        source: defaults.terrainSourceId,\n        exaggeration: 0,\n      });\n    };\n\n    // The terrain has already been loaded,\n    // we just update the exaggeration.\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = true;\n      this.growTerrain(exaggeration);\n      return;\n    }\n\n    if (this.loaded() || this.isTerrainEnabled) {\n      addTerrain();\n    } else {\n      this.once(\"load\", () => {\n        if (this.getTerrain() && this.getSource(defaults.terrainSourceId)) {\n          return;\n        }\n        addTerrain();\n      });\n    }\n  }\n\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    // It could be disabled already\n    if (!this.terrain) {\n      return;\n    }\n\n    this.isTerrainEnabled = false;\n    // this.stopFlattening = false;\n\n    // Duration of the animation in millisec\n    const animationLoopDuration = 1 * 1000;\n    const startTime = performance.now();\n    // This is supposedly 0, but it could be something else (e.g. already in the middle of growing, or user defined other)\n    const currentExaggeration = this.terrain.exaggeration;\n\n    // This is again called in a requestAnimationFrame ~loop, until the terrain has grown enough\n    // that it has reached the target\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n\n      // If the growing animation is triggered while flattening,\n      // then we exist the flatening\n      if (this.terrainGrowing) {\n        return;\n      }\n\n      // normalized value in interval [0, 1] of where we are currently in the animation loop\n      const positionInLoop =\n        (performance.now() - startTime) / animationLoopDuration;\n\n      // The animation goes on until we reached 99% of the growing sequence duration\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration * exaggerationFactor;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrain.exaggeration = 0;\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.setTerrain(null);\n        if (this.getSource(defaults.terrainSourceId)) {\n          this.removeSource(defaults.terrainSourceId);\n        }\n      }\n\n      this.triggerRepaint();\n    };\n\n    this.terrainGrowing = false;\n    this.terrainFlattening = true;\n    requestAnimationFrame(updateExaggeration);\n  }\n\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   * @param exaggeration\n   * @param animate\n   */\n  setTerrainExaggeration(exaggeration: number, animate = true) {\n    if (!animate && this.terrain) {\n      this.terrainExaggeration = exaggeration;\n      this.terrain.exaggeration = exaggeration;\n      this.triggerRepaint();\n    } else {\n      this.enableTerrain(exaggeration);\n    }\n  }\n\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   * @param cb\n   */\n  private onStyleReady(cb) {\n    if (this.isStyleLoaded()) {\n      cb();\n    } else {\n      this.once(\"styledata\", () => {\n        cb();\n      });\n    }\n  }\n\n  async fitToIpBounds() {\n    const ipGeolocateResult = await geolocation.info();\n    this.fitBounds(\n      ipGeolocateResult.country_bounds as [number, number, number, number],\n      {\n        duration: 0,\n        padding: 100,\n      }\n    );\n  }\n\n  async centerOnIpPoint(zoom: number | undefined) {\n    const ipGeolocateResult = await geolocation.info();\n    this.jumpTo({\n      center: [ipGeolocateResult.longitude, ipGeolocateResult.latitude],\n      zoom: zoom || 11,\n    });\n  }\n\n  getCameraHash() {\n    const hashBin = new Float32Array(5);\n    const center = this.getCenter();\n    hashBin[0] = center.lng;\n    hashBin[1] = center.lat;\n    hashBin[2] = this.getZoom();\n    hashBin[3] = this.getPitch();\n    hashBin[4] = this.getBearing();\n    return Base64.fromUint8Array(new Uint8Array(hashBin.buffer));\n  }\n\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getSdkConfig(): SdkConfig {\n    return config;\n  }\n\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId(): string {\n    return MAPTILER_SESSION_ID;\n  }\n\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(transformRequest: RequestTransformFunction) {\n    super.setTransformRequest(combineTransformRequest(transformRequest));\n    return this;\n  }\n}\n","/**\n * This is an extension of MapLibre Marker to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class Marker extends maplibregl.Marker {\n  addTo(map: Map | MapMLGL): this {\n    return super.addTo(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre Popup to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class Popup extends maplibregl.Popup {\n  addTo(map: Map | MapMLGL): this {\n    return super.addTo(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre Style to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL, StyleOptions } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class Style extends maplibregl.Style {\n  constructor(map: Map, options: StyleOptions = {}) {\n    super(map as MapMLGL, options);\n  }\n}\n","/**\n * This is an extension of MapLibre CanvasSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class CanvasSource extends maplibregl.CanvasSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre GeoJSONSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class GeoJSONSource extends maplibregl.GeoJSONSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre ImageSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class ImageSource extends maplibregl.ImageSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre RasterTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class RasterTileSource extends maplibregl.RasterTileSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre RasterDEMTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class RasterDEMTileSource extends maplibregl.RasterDEMTileSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre VectorTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class VectorTileSource extends maplibregl.VectorTileSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre VideoSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class VideoSource extends maplibregl.VideoSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre TerrainControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class TerrainControl extends maplibregl.TerrainControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is TypeScript rewrite of the Point class to use instead of the version imported in MapLibre.\n * It also uses a class instead of prototypes.\n */\n\n/**\n * Row major 2x2 matrix\n */\nexport type Matrix2 = [number, number, number, number];\n\n/**\n * a point\n * @param x\n * @param y\n */\nexport class Point {\n  public x: number;\n  public y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  private _matMult(m: Matrix2): Point {\n    const x = m[0] * this.x + m[1] * this.y;\n    const y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  private _add(p: Point): Point {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  private _sub(p: Point): Point {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  }\n\n  private _mult(k: number): Point {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n\n  private _div(k: number): Point {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  }\n\n  private _multByPoint(p: Point): Point {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  }\n\n  private _divByPoint(p: Point): Point {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  }\n\n  private _unit(): Point {\n    this._div(this.mag());\n    return this;\n  }\n\n  private _perp(): Point {\n    const y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  }\n\n  private _rotate(angle: number): Point {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * this.x - sin * this.y;\n    const y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  private _rotateAround(angle: number, p: Point): Point {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y);\n    const y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  private _round(): Point {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add(p: Point): Point {\n    return this.clone()._add(p);\n  }\n\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub(p: Point): Point {\n    return this.clone()._sub(p);\n  }\n\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint(p: Point): Point {\n    return this.clone()._multByPoint(p);\n  }\n\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint(p: Point): Point {\n    return this.clone()._divByPoint(p);\n  }\n\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Number} k factor\n   * @return {Point} output point\n   */\n  mult(k: number): Point {\n    return this.clone()._mult(k);\n  }\n\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div(k: number): Point {\n    return this.clone()._div(k);\n  }\n\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate(a: number): Point {\n    return this.clone()._rotate(a);\n  }\n\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround(a: number, p: Point): Point {\n    return this.clone()._rotateAround(a, p);\n  }\n\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult(m: Matrix2): Point {\n    return this.clone()._matMult(m);\n  }\n\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit(): Point {\n    return this.clone()._unit();\n  }\n\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp(): Point {\n    return this.clone()._perp();\n  }\n\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round(): Point {\n    return this.clone()._round();\n  }\n\n  /**\n   * Return the magnitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag(): number {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals(other): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist(p): number {\n    return Math.sqrt(this.distSqr(p));\n  }\n\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr(p): number {\n    const dx = p.x - this.x;\n    const dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo(b: Point): number {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  }\n\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith(b: Point): number {\n    return this.angleWithSep(b.x, b.y);\n  }\n\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin(θ) for θ.\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep(x: number, y: number): number {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  }\n\n  /**\n   * Construct a point from an array if necessary, otherwise if the input\n   * is already a Point, or an unknown type, return it unchanged\n   * @param {Array<number> | Point} a any kind of input value\n   * @return {Point} constructed point, or passed-through value.\n   * @example\n   * // this\n   * var point = Point.convert([0, 1]);\n   * // is equivalent to\n   * var point = new Point(0, 1);\n   */\n  static convert(a: Point | Array<number>) {\n    if (a instanceof Point) {\n      return a;\n    }\n    if (Array.isArray(a)) {\n      return new Point(a[0], a[1]);\n    }\n    return a;\n  }\n}\n","/**\n * Maplibre export first, then extensions can overload the exports.\n */\nexport * from \"maplibre-gl\";\n\n/**\n * To perform explicit named export so that they are included in the UMD bundle\n */\n// import * as ML from \"maplibre-gl\";\n\nimport maplibregl from \"maplibre-gl\";\n\nconst {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol,\n} = maplibregl;\n\n// We still want to export maplibregl.Map, but as a different name\nconst MapMLGL = maplibregl.Map;\nconst MarkerMLGL = maplibregl.Marker;\nconst PopupMLGL = maplibregl.Popup;\nconst StyleMLGL = maplibregl.Style;\nconst CanvasSourceMLGL = maplibregl.CanvasSource;\nconst GeoJSONSourceMLGL = maplibregl.GeoJSONSource;\nconst ImageSourceMLGL = maplibregl.ImageSource;\nconst RasterTileSourceMLGL = maplibregl.RasterTileSource;\nconst RasterDEMTileSourceMLGL = maplibregl.RasterDEMTileSource;\nconst VectorTileSourceMLGL = maplibregl.VectorTileSource;\nconst VideoSourceMLGL = maplibregl.VideoSource;\nconst NavigationControlMLGL = maplibregl.NavigationControl;\nconst GeolocateControlMLGL = maplibregl.GeolocateControl;\nconst AttributionControlMLGL = maplibregl.AttributionControl;\nconst LogoControlMLGL = maplibregl.LogoControl;\nconst ScaleControlMLGL = maplibregl.ScaleControl;\nconst FullscreenControlMLGL = maplibregl.FullscreenControl;\nconst TerrainControlMLGL = maplibregl.TerrainControl;\n\nexport {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  PopupMLGL,\n  MarkerMLGL,\n  StyleMLGL,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  CanvasSourceMLGL,\n  GeoJSONSourceMLGL,\n  ImageSourceMLGL,\n  RasterDEMTileSourceMLGL,\n  RasterTileSourceMLGL,\n  VectorTileSourceMLGL,\n  VideoSourceMLGL,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol,\n  MapMLGL,\n};\n\n// Exporting types of class instances from MapLibre:\nexport type NavigationControlMLGL = InstanceType<typeof NavigationControlMLGL>;\nexport type GeolocateControlMLGL = InstanceType<typeof GeolocateControlMLGL>;\nexport type AttributionControlMLGL = InstanceType<\n  typeof AttributionControlMLGL\n>;\nexport type LogoControlMLGL = InstanceType<typeof LogoControlMLGL>;\nexport type ScaleControlMLGL = InstanceType<typeof ScaleControlMLGL>;\nexport type FullscreenControlMLGL = InstanceType<typeof FullscreenControlMLGL>;\nexport type TerrainControlMLGL = InstanceType<typeof TerrainControlMLGL>;\nexport type MarkerMLGL = InstanceType<typeof MarkerMLGL>;\nexport type PopupMLGL = InstanceType<typeof PopupMLGL>;\nexport type StyleMLGL = InstanceType<typeof StyleMLGL>;\nexport type LngLat = InstanceType<typeof LngLat>;\nexport type LngLatBounds = InstanceType<typeof LngLatBounds>;\nexport type MercatorCoordinate = InstanceType<typeof MercatorCoordinate>;\nexport type Evented = InstanceType<typeof Evented>;\nexport type AJAXError = InstanceType<typeof AJAXError>;\nexport type CanvasSourceMLGL = InstanceType<typeof CanvasSourceMLGL>;\nexport type GeoJSONSourceMLGL = InstanceType<typeof GeoJSONSourceMLGL>;\nexport type ImageSourceMLGL = InstanceType<typeof ImageSourceMLGL>;\nexport type RasterDEMTileSourceMLGL = InstanceType<\n  typeof RasterDEMTileSourceMLGL\n>;\nexport type RasterTileSourceMLGL = InstanceType<typeof RasterTileSourceMLGL>;\nexport type VectorTileSourceMLGL = InstanceType<typeof VectorTileSourceMLGL>;\nexport type VideoSourceMLGL = InstanceType<typeof VideoSourceMLGL>;\nexport type MapMLGL = InstanceType<typeof MapMLGL>;\n\n// SDK specific\nimport { Map, GeolocationType } from \"./Map\";\nimport type { MapOptions, LoadWithTerrainEvent } from \"./Map\";\n\nimport { Marker } from \"./Marker\";\nimport { Popup } from \"./Popup\";\nimport { Style } from \"./Style\";\nimport { CanvasSource } from \"./CanvasSource\";\nimport { GeoJSONSource } from \"./GeoJSONSource\";\nimport { ImageSource } from \"./ImageSource\";\nimport { RasterTileSource } from \"./RasterTileSource\";\nimport { RasterDEMTileSource } from \"./RasterDEMTileSource\";\nimport { VectorTileSource } from \"./VectorTileSource\";\nimport { VideoSource } from \"./VideoSource\";\nimport { NavigationControl } from \"./NavigationControl\";\nimport { GeolocateControl } from \"./GeolocateControl\";\nimport { AttributionControl } from \"./AttributionControl\";\nimport { LogoControl } from \"./LogoControl\";\nimport { ScaleControl } from \"./ScaleControl\";\nimport { FullscreenControl } from \"./FullscreenControl\";\nimport { TerrainControl } from \"./TerrainControl\";\n\n// Import of modified versions of the controls\nimport { MaptilerGeolocateControl } from \"./MaptilerGeolocateControl\";\nimport { MaptilerLogoControl } from \"./MaptilerLogoControl\";\nimport { MaptilerTerrainControl } from \"./MaptilerTerrainControl\";\nimport { MaptilerNavigationControl } from \"./MaptilerNavigationControl\";\n\n// importing client functions to expose them as part of the SDK\nimport type {\n  BBox,\n  Position,\n  GeocodingOptions,\n  CoordinatesSearchOptions,\n  CenteredStaticMapOptions,\n  AutomaticStaticMapOptions,\n  BoundedStaticMapOptions,\n} from \"@maptiler/client\";\n\nimport {\n  geocoding,\n  geolocation,\n  coordinates,\n  data,\n  staticMaps,\n  ServiceError,\n  LanguageGeocoding,\n  LanguageGeocodingString,\n  ReferenceMapStyle,\n  MapStyle,\n  MapStyleVariant,\n} from \"@maptiler/client\";\n\nimport type { MapStyleType } from \"@maptiler/client\";\n\nimport { Point } from \"./Point\";\nimport type { Matrix2 } from \"./Point\";\n\n// Importing enums and configs\nimport { config, SdkConfig } from \"./config\";\nimport { Language, LanguageString, LanguageKey } from \"./language\";\nimport type { Unit } from \"./unit\";\n\n// Exporting types\nexport type {\n  MapOptions,\n  LoadWithTerrainEvent,\n  GeocodingOptions,\n  BBox,\n  Position,\n  CoordinatesSearchOptions,\n  CenteredStaticMapOptions,\n  BoundedStaticMapOptions,\n  AutomaticStaticMapOptions,\n  LanguageString,\n  LanguageKey,\n  LanguageGeocodingString,\n  Unit,\n  MapStyleType,\n  Matrix2,\n};\n\n// Exporting classes, objects, functions, etc.\nexport {\n  Map,\n  Marker,\n  Popup,\n  Style,\n  CanvasSource,\n  GeoJSONSource,\n  ImageSource,\n  RasterTileSource,\n  RasterDEMTileSource,\n  VideoSource,\n  NavigationControl,\n  GeolocateControl,\n  AttributionControl,\n  LogoControl,\n  ScaleControl,\n  FullscreenControl,\n  TerrainControl,\n  VectorTileSource,\n  GeolocationType,\n  SdkConfig,\n  config,\n  ServiceError,\n  geocoding,\n  geolocation,\n  coordinates,\n  data,\n  staticMaps,\n  MapStyle,\n  Language,\n  LanguageGeocoding,\n  Point,\n  ReferenceMapStyle,\n  MapStyleVariant,\n  MaptilerGeolocateControl,\n  MaptilerLogoControl,\n  MaptilerTerrainControl,\n  MaptilerNavigationControl,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}